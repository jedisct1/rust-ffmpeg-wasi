/* automatically generated by rust-bindgen 0.57.0 */

pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const _BSD_SOURCE: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PAGESIZE: u32 = 65536;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 131072;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 32;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const PAGE_SIZE: u32 = 65536;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 1000;
pub const L_ctermid: u32 = 20;
pub const L_cuserid: u32 = 20;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 56;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 67;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 0;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const __GNUC_VA_LIST: u32 = 1;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: u32 = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: u32 = 8;
pub const LIBAVFILTER_VERSION_MAJOR: u32 = 7;
pub const LIBAVFILTER_VERSION_MINOR: u32 = 109;
pub const LIBAVFILTER_VERSION_MICRO: u32 = 100;
pub const AVFILTER_FLAG_DYNAMIC_INPUTS: u32 = 1;
pub const AVFILTER_FLAG_DYNAMIC_OUTPUTS: u32 = 2;
pub const AVFILTER_FLAG_SLICE_THREADS: u32 = 4;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC: u32 = 65536;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL: u32 = 131072;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE: u32 = 196608;
pub const AVFILTER_THREAD_SLICE: u32 = 1;
pub const AVFILTER_CMD_FLAG_ONE: u32 = 1;
pub const AVFILTER_CMD_FLAG_FAST: u32 = 2;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
extern "C" {
    #[doc = " Return the LIBAVUTIL_VERSION_INT constant."]
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return an informative version string. This usually is the actual release"]
    #[doc = " version number or a git commit description. This string has no fixed format"]
    #[doc = " and can change any time. It should never be parsed by code."]
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavutil build-time configuration."]
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavutil license."]
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
#[doc = "< Usually treated as AVMEDIA_TYPE_DATA"]
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
#[doc = "< Opaque data information usually continuous"]
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
#[doc = "< Opaque data information usually sparse"]
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
#[doc = " @addtogroup lavu_media Media Type"]
#[doc = " @brief Media Type"]
pub type AVMediaType = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Return a string describing the media_type enum, NULL if media_type"]
    #[doc = " is unknown."]
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
#[doc = "< Undefined"]
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
#[doc = "< Intra"]
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
#[doc = "< Predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
#[doc = "< Bi-dir predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
#[doc = "< S(GMC)-VOP MPEG-4"]
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
#[doc = "< Switching Intra"]
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
#[doc = "< Switching Predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
#[doc = "< BI type"]
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
#[doc = " @}"]
#[doc = " @}"]
#[doc = " @defgroup lavu_picture Image related"]
#[doc = ""]
#[doc = " AVPicture types, pixel formats and basic image planes manipulation."]
#[doc = ""]
#[doc = " @{"]
pub type AVPictureType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Return a single letter to describe the given picture type"]
    #[doc = " pict_type."]
    #[doc = ""]
    #[doc = " @param[in] pict_type the picture type @return a single character"]
    #[doc = " representing the picture type, '?' if pict_type is unknown"]
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
extern "C" {
    pub static mut errno: ::std::os::raw::c_int;
}
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type time_t = ::std::os::raw::c_longlong;
pub type suseconds_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type __wasi_size_t = ::std::os::raw::c_ulong;
pub type __wasi_filesize_t = u64;
pub type __wasi_timestamp_t = u64;
pub type __wasi_clockid_t = u32;
pub type __wasi_errno_t = u16;
pub type __wasi_rights_t = u64;
pub type __wasi_fd_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_iovec_t {
    pub buf: *mut u8,
    pub buf_len: __wasi_size_t,
}
impl Default for __wasi_iovec_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_ciovec_t {
    pub buf: *const u8,
    pub buf_len: __wasi_size_t,
}
impl Default for __wasi_ciovec_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __wasi_filedelta_t = i64;
pub type __wasi_whence_t = u8;
pub type __wasi_dircookie_t = u64;
pub type __wasi_dirnamlen_t = u32;
pub type __wasi_inode_t = u64;
pub type __wasi_filetype_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_dirent_t {
    pub d_next: __wasi_dircookie_t,
    pub d_ino: __wasi_inode_t,
    pub d_namlen: __wasi_dirnamlen_t,
    pub d_type: __wasi_filetype_t,
}
pub type __wasi_advice_t = u8;
pub type __wasi_fdflags_t = u16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_fdstat_t {
    pub fs_filetype: __wasi_filetype_t,
    pub fs_flags: __wasi_fdflags_t,
    pub fs_rights_base: __wasi_rights_t,
    pub fs_rights_inheriting: __wasi_rights_t,
}
pub type __wasi_device_t = u64;
pub type __wasi_fstflags_t = u16;
pub type __wasi_lookupflags_t = u32;
pub type __wasi_oflags_t = u16;
pub type __wasi_linkcount_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_filestat_t {
    pub dev: __wasi_device_t,
    pub ino: __wasi_inode_t,
    pub filetype: __wasi_filetype_t,
    pub nlink: __wasi_linkcount_t,
    pub size: __wasi_filesize_t,
    pub atim: __wasi_timestamp_t,
    pub mtim: __wasi_timestamp_t,
    pub ctim: __wasi_timestamp_t,
}
pub type __wasi_userdata_t = u64;
pub type __wasi_eventtype_t = u8;
pub type __wasi_eventrwflags_t = u16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_event_fd_readwrite_t {
    pub nbytes: __wasi_filesize_t,
    pub flags: __wasi_eventrwflags_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_event_t {
    pub userdata: __wasi_userdata_t,
    pub error: __wasi_errno_t,
    pub type_: __wasi_eventtype_t,
    pub fd_readwrite: __wasi_event_fd_readwrite_t,
}
pub type __wasi_subclockflags_t = u16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_subscription_clock_t {
    pub id: __wasi_clockid_t,
    pub timeout: __wasi_timestamp_t,
    pub precision: __wasi_timestamp_t,
    pub flags: __wasi_subclockflags_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_subscription_fd_readwrite_t {
    pub file_descriptor: __wasi_fd_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_subscription_u_u_t {
    pub clock: __wasi_subscription_clock_t,
    pub fd_read: __wasi_subscription_fd_readwrite_t,
    pub fd_write: __wasi_subscription_fd_readwrite_t,
    _bindgen_union_align: [u64; 4usize],
}
impl Default for __wasi_subscription_u_u_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_u_t {
    pub tag: __wasi_eventtype_t,
    pub u: __wasi_subscription_u_u_t,
}
impl Default for __wasi_subscription_u_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_t {
    pub userdata: __wasi_userdata_t,
    pub u: __wasi_subscription_u_t,
}
impl Default for __wasi_subscription_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __wasi_exitcode_t = u32;
pub type __wasi_signal_t = u8;
pub type __wasi_riflags_t = u16;
pub type __wasi_roflags_t = u16;
pub type __wasi_siflags_t = u16;
pub type __wasi_sdflags_t = u8;
pub type __wasi_preopentype_t = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_prestat_dir_t {
    pub pr_name_len: __wasi_size_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_prestat_u_t {
    pub dir: __wasi_prestat_dir_t,
    _bindgen_union_align: u32,
}
impl Default for __wasi_prestat_u_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_prestat_t {
    pub tag: __wasi_preopentype_t,
    pub u: __wasi_prestat_u_t,
}
impl Default for __wasi_prestat_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[must_use]
    pub fn __wasi_args_get(argv: *mut *mut u8, argv_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_args_sizes_get(
        argc: *mut __wasi_size_t,
        argv_buf_size: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_environ_get(environ: *mut *mut u8, environ_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_environ_sizes_get(
        environc: *mut __wasi_size_t,
        environ_buf_size: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_clock_res_get(
        id: __wasi_clockid_t,
        resolution: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_clock_time_get(
        id: __wasi_clockid_t,
        precision: __wasi_timestamp_t,
        time: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_advise(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
        advice: __wasi_advice_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_allocate(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_close(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_datasync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_fdstat_get(fd: __wasi_fd_t, stat: *mut __wasi_fdstat_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_fdstat_set_flags(fd: __wasi_fd_t, flags: __wasi_fdflags_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_fdstat_set_rights(
        fd: __wasi_fd_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inheriting: __wasi_rights_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_filestat_get(fd: __wasi_fd_t, buf: *mut __wasi_filestat_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_filestat_set_size(fd: __wasi_fd_t, size: __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_filestat_set_times(
        fd: __wasi_fd_t,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_pread(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        nread: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_prestat_get(fd: __wasi_fd_t, buf: *mut __wasi_prestat_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_prestat_dir_name(
        fd: __wasi_fd_t,
        path: *mut u8,
        path_len: __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_pwrite(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        nwritten: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_read(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        nread: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_readdir(
        fd: __wasi_fd_t,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        cookie: __wasi_dircookie_t,
        bufused: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_renumber(fd: __wasi_fd_t, to: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_seek(
        fd: __wasi_fd_t,
        offset: __wasi_filedelta_t,
        whence: __wasi_whence_t,
        newoffset: *mut __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_sync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_tell(fd: __wasi_fd_t, offset: *mut __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_fd_write(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        nwritten: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_create_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_filestat_get(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        buf: *mut __wasi_filestat_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_filestat_set_times(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_link(
        old_fd: __wasi_fd_t,
        old_flags: __wasi_lookupflags_t,
        old_path: *const ::std::os::raw::c_char,
        old_path_len: usize,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
        new_path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_open(
        fd: __wasi_fd_t,
        dirflags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        oflags: __wasi_oflags_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inherting: __wasi_rights_t,
        fdflags: __wasi_fdflags_t,
        opened_fd: *mut __wasi_fd_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_readlink(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        bufused: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_remove_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_rename(
        fd: __wasi_fd_t,
        old_path: *const ::std::os::raw::c_char,
        old_path_len: usize,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
        new_path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_symlink(
        old_path: *const ::std::os::raw::c_char,
        old_path_len: usize,
        fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
        new_path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_path_unlink_file(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        path_len: usize,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_poll_oneoff(
        in_: *const __wasi_subscription_t,
        out: *mut __wasi_event_t,
        nsubscriptions: __wasi_size_t,
        nevents: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    pub fn __wasi_proc_exit(rval: __wasi_exitcode_t);
}
extern "C" {
    #[must_use]
    pub fn __wasi_proc_raise(sig: __wasi_signal_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_sched_yield() -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_random_get(buf: *mut u8, buf_len: __wasi_size_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_sock_recv(
        fd: __wasi_fd_t,
        ri_data: *const __wasi_iovec_t,
        ri_data_len: usize,
        ri_flags: __wasi_riflags_t,
        ro_datalen: *mut __wasi_size_t,
        ro_flags: *mut __wasi_roflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_sock_send(
        fd: __wasi_fd_t,
        si_data: *const __wasi_ciovec_t,
        si_data_len: usize,
        si_flags: __wasi_siflags_t,
        so_datalen: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    pub fn __wasi_sock_shutdown(fd: __wasi_fd_t, how: __wasi_sdflags_t) -> __wasi_errno_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalbf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
extern "C" {
    pub fn significandf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
pub type off_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type __isoc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::std::os::raw::c_char; 16usize],
    pub __lldata: ::std::os::raw::c_longlong,
    pub __align: f64,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type fpos_t = _G_fpos64_t;
extern "C" {
    pub static stdin: *mut FILE;
}
extern "C" {
    pub static stdout: *mut FILE;
}
extern "C" {
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE);
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char, arg3: usize);
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[must_use]
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[must_use]
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn aligned_alloc(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4random_uniform(arg1: u32) -> u32;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __dst: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put a description of the AVERROR code errnum in errbuf."]
    #[doc = " In case of failure the global variable errno is set to indicate the"]
    #[doc = " error. Even in case of failure av_strerror() will print a generic"]
    #[doc = " error message indicating the errnum provided to errbuf."]
    #[doc = ""]
    #[doc = " @param errnum      error code to describe"]
    #[doc = " @param errbuf      buffer to which description is written"]
    #[doc = " @param errbuf_size the size in bytes of errbuf"]
    #[doc = " @return 0 on success, a negative value if a description for errnum"]
    #[doc = " cannot be found"]
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses"]
    #[doc = " (including vectors if available on the CPU)."]
    #[doc = ""]
    #[doc = " @param size Size in bytes for the memory block to be allocated"]
    #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
    #[doc = "         be allocated"]
    #[doc = " @see av_mallocz()"]
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses"]
    #[doc = " (including vectors if available on the CPU) and zero all the bytes of the"]
    #[doc = " block."]
    #[doc = ""]
    #[doc = " @param size Size in bytes for the memory block to be allocated"]
    #[doc = " @return Pointer to the allocated block, or `NULL` if it cannot be allocated"]
    #[doc = " @see av_malloc()"]
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_malloc()."]
    #[doc = ""]
    #[doc = " The allocated memory will have size `size * nmemb` bytes."]
    #[doc = ""]
    #[doc = " @param nmemb Number of element"]
    #[doc = " @param size  Size of a single element"]
    #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
    #[doc = "         be allocated"]
    #[doc = " @see av_malloc()"]
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_mallocz()."]
    #[doc = ""]
    #[doc = " The allocated memory will have size `size * nmemb` bytes."]
    #[doc = ""]
    #[doc = " @param nmemb Number of elements"]
    #[doc = " @param size  Size of the single element"]
    #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
    #[doc = "         be allocated"]
    #[doc = ""]
    #[doc = " @see av_mallocz()"]
    #[doc = " @see av_malloc_array()"]
    pub fn av_mallocz_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Non-inlined equivalent of av_mallocz_array()."]
    #[doc = ""]
    #[doc = " Created for symmetry with the calloc() C function."]
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory."]
    #[doc = ""]
    #[doc = " If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is"]
    #[doc = " zero, free the memory block pointed to by `ptr`. Otherwise, expand or"]
    #[doc = " shrink that block of memory according to `size`."]
    #[doc = ""]
    #[doc = " @param ptr  Pointer to a memory block already allocated with"]
    #[doc = "             av_realloc() or `NULL`"]
    #[doc = " @param size Size in bytes of the memory block to be allocated or"]
    #[doc = "             reallocated"]
    #[doc = ""]
    #[doc = " @return Pointer to a newly-reallocated block or `NULL` if the block"]
    #[doc = "         cannot be reallocated or the function is used to free the memory block"]
    #[doc = ""]
    #[doc = " @warning Unlike av_malloc(), the returned pointer is not guaranteed to be"]
    #[doc = "          correctly aligned."]
    #[doc = " @see av_fast_realloc()"]
    #[doc = " @see av_reallocp()"]
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    #[doc = " Allocate, reallocate, or free a block of memory through a pointer to a"]
    #[doc = " pointer."]
    #[doc = ""]
    #[doc = " If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is"]
    #[doc = " zero, free the memory block pointed to by `*ptr`. Otherwise, expand or"]
    #[doc = " shrink that block of memory according to `size`."]
    #[doc = ""]
    #[doc = " @param[in,out] ptr  Pointer to a pointer to a memory block already allocated"]
    #[doc = "                     with av_realloc(), or a pointer to `NULL`. The pointer"]
    #[doc = "                     is updated on success, or freed on failure."]
    #[doc = " @param[in]     size Size in bytes for the memory block to be allocated or"]
    #[doc = "                     reallocated"]
    #[doc = ""]
    #[doc = " @return Zero on success, an AVERROR error code on failure"]
    #[doc = ""]
    #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
    #[doc = "          correctly aligned."]
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory."]
    #[doc = ""]
    #[doc = " This function does the same thing as av_realloc(), except:"]
    #[doc = " - It takes two size arguments and allocates `nelem * elsize` bytes,"]
    #[doc = "   after checking the result of the multiplication for integer overflow."]
    #[doc = " - It frees the input block in case of failure, thus avoiding the memory"]
    #[doc = "   leak with the classic"]
    #[doc = "   @code{.c}"]
    #[doc = "   buf = realloc(buf);"]
    #[doc = "   if (!buf)"]
    #[doc = "       return -1;"]
    #[doc = "   @endcode"]
    #[doc = "   pattern."]
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free an array."]
    #[doc = ""]
    #[doc = " If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If"]
    #[doc = " `nmemb` is zero, free the memory block pointed to by `ptr`."]
    #[doc = ""]
    #[doc = " @param ptr   Pointer to a memory block already allocated with"]
    #[doc = "              av_realloc() or `NULL`"]
    #[doc = " @param nmemb Number of elements in the array"]
    #[doc = " @param size  Size of the single element of the array"]
    #[doc = ""]
    #[doc = " @return Pointer to a newly-reallocated block or NULL if the block"]
    #[doc = "         cannot be reallocated or the function is used to free the memory block"]
    #[doc = ""]
    #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
    #[doc = "          correctly aligned."]
    #[doc = " @see av_reallocp_array()"]
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free an array through a pointer to a pointer."]
    #[doc = ""]
    #[doc = " If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is"]
    #[doc = " zero, free the memory block pointed to by `*ptr`."]
    #[doc = ""]
    #[doc = " @param[in,out] ptr   Pointer to a pointer to a memory block already"]
    #[doc = "                      allocated with av_realloc(), or a pointer to `NULL`."]
    #[doc = "                      The pointer is updated on success, or freed on failure."]
    #[doc = " @param[in]     nmemb Number of elements"]
    #[doc = " @param[in]     size  Size of the single element"]
    #[doc = ""]
    #[doc = " @return Zero on success, an AVERROR error code on failure"]
    #[doc = ""]
    #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
    #[doc = "          correctly aligned."]
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reallocate the given buffer if it is not large enough, otherwise do nothing."]
    #[doc = ""]
    #[doc = " If the given buffer is `NULL`, then a new uninitialized buffer is allocated."]
    #[doc = ""]
    #[doc = " If the given buffer is not large enough, and reallocation fails, `NULL` is"]
    #[doc = " returned and `*size` is set to 0, but the original buffer is not changed or"]
    #[doc = " freed."]
    #[doc = ""]
    #[doc = " A typical use pattern follows:"]
    #[doc = ""]
    #[doc = " @code{.c}"]
    #[doc = " uint8_t *buf = ...;"]
    #[doc = " uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);"]
    #[doc = " if (!new_buf) {"]
    #[doc = "     // Allocation failed; clean up original buffer"]
    #[doc = "     av_freep(&buf);"]
    #[doc = "     return AVERROR(ENOMEM);"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param[in,out] ptr      Already allocated buffer, or `NULL`"]
    #[doc = " @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is"]
    #[doc = "                         updated to the new allocated size, in particular 0"]
    #[doc = "                         in case of failure."]
    #[doc = " @param[in]     min_size Desired minimal size of buffer `ptr`"]
    #[doc = " @return `ptr` if the buffer is large enough, a pointer to newly reallocated"]
    #[doc = "         buffer if the buffer was not large enough, or `NULL` in case of"]
    #[doc = "         error"]
    #[doc = " @see av_realloc()"]
    #[doc = " @see av_fast_malloc()"]
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a buffer, reusing the given one if large enough."]
    #[doc = ""]
    #[doc = " Contrary to av_fast_realloc(), the current buffer contents might not be"]
    #[doc = " preserved and on error the old buffer is freed, thus no special handling to"]
    #[doc = " avoid memleaks is necessary."]
    #[doc = ""]
    #[doc = " `*ptr` is allowed to be `NULL`, in which case allocation always happens if"]
    #[doc = " `size_needed` is greater than 0."]
    #[doc = ""]
    #[doc = " @code{.c}"]
    #[doc = " uint8_t *buf = ...;"]
    #[doc = " av_fast_malloc(&buf, &current_size, size_needed);"]
    #[doc = " if (!buf) {"]
    #[doc = "     // Allocation failed; buf already freed"]
    #[doc = "     return AVERROR(ENOMEM);"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param[in,out] ptr      Pointer to pointer to an already allocated buffer."]
    #[doc = "                         `*ptr` will be overwritten with pointer to new"]
    #[doc = "                         buffer on success or `NULL` on failure"]
    #[doc = " @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is"]
    #[doc = "                         updated to the new allocated size, in particular 0"]
    #[doc = "                         in case of failure."]
    #[doc = " @param[in]     min_size Desired minimal size of buffer `*ptr`"]
    #[doc = " @see av_realloc()"]
    #[doc = " @see av_fast_mallocz()"]
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Allocate and clear a buffer, reusing the given one if large enough."]
    #[doc = ""]
    #[doc = " Like av_fast_malloc(), but all newly allocated space is initially cleared."]
    #[doc = " Reused buffer is not cleared."]
    #[doc = ""]
    #[doc = " `*ptr` is allowed to be `NULL`, in which case allocation always happens if"]
    #[doc = " `size_needed` is greater than 0."]
    #[doc = ""]
    #[doc = " @param[in,out] ptr      Pointer to pointer to an already allocated buffer."]
    #[doc = "                         `*ptr` will be overwritten with pointer to new"]
    #[doc = "                         buffer on success or `NULL` on failure"]
    #[doc = " @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is"]
    #[doc = "                         updated to the new allocated size, in particular 0"]
    #[doc = "                         in case of failure."]
    #[doc = " @param[in]     min_size Desired minimal size of buffer `*ptr`"]
    #[doc = " @see av_fast_malloc()"]
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()"]
    #[doc = " or av_realloc() family."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to the memory block which should be freed."]
    #[doc = ""]
    #[doc = " @note `ptr = NULL` is explicitly allowed."]
    #[doc = " @note It is recommended that you use av_freep() instead, to prevent leaving"]
    #[doc = "       behind dangling pointers."]
    #[doc = " @see av_freep()"]
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()"]
    #[doc = " or av_realloc() family, and set the pointer pointing to it to `NULL`."]
    #[doc = ""]
    #[doc = " @code{.c}"]
    #[doc = " uint8_t *buf = av_malloc(16);"]
    #[doc = " av_free(buf);"]
    #[doc = " // buf now contains a dangling pointer to freed memory, and accidental"]
    #[doc = " // dereference of buf will result in a use-after-free, which may be a"]
    #[doc = " // security risk."]
    #[doc = ""]
    #[doc = " uint8_t *buf = av_malloc(16);"]
    #[doc = " av_freep(&buf);"]
    #[doc = " // buf is now NULL, and accidental dereference will only result in a"]
    #[doc = " // NULL-pointer dereference."]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param ptr Pointer to the pointer to the memory block which should be freed"]
    #[doc = " @note `*ptr = NULL` is safe and leads to no action."]
    #[doc = " @see av_free()"]
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Duplicate a string."]
    #[doc = ""]
    #[doc = " @param s String to be duplicated"]
    #[doc = " @return Pointer to a newly-allocated string containing a"]
    #[doc = "         copy of `s` or `NULL` if the string cannot be allocated"]
    #[doc = " @see av_strndup()"]
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate a substring of a string."]
    #[doc = ""]
    #[doc = " @param s   String to be duplicated"]
    #[doc = " @param len Maximum length of the resulting string (not counting the"]
    #[doc = "            terminating byte)"]
    #[doc = " @return Pointer to a newly-allocated string containing a"]
    #[doc = "         substring of `s` or `NULL` if the string cannot be allocated"]
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate a buffer with av_malloc()."]
    #[doc = ""]
    #[doc = " @param p    Buffer to be duplicated"]
    #[doc = " @param size Size in bytes of the buffer copied"]
    #[doc = " @return Pointer to a newly allocated buffer containing a"]
    #[doc = "         copy of `p` or `NULL` if the buffer cannot be allocated"]
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Overlapping memcpy() implementation."]
    #[doc = ""]
    #[doc = " @param dst  Destination buffer"]
    #[doc = " @param back Number of bytes back to start copying (i.e. the initial size of"]
    #[doc = "             the overlapping window); must be > 0"]
    #[doc = " @param cnt  Number of bytes to copy; must be >= 0"]
    #[doc = ""]
    #[doc = " @note `cnt > back` is valid, this will copy the bytes we just copied,"]
    #[doc = "       thus creating a repeating pattern with a period length of `back`."]
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Add the pointer to an element to a dynamic array."]
    #[doc = ""]
    #[doc = " The array to grow is supposed to be an array of pointers to"]
    #[doc = " structures, and the element to add must be a pointer to an already"]
    #[doc = " allocated structure."]
    #[doc = ""]
    #[doc = " The array is reallocated when its size reaches powers of 2."]
    #[doc = " Therefore, the amortized cost of adding an element is constant."]
    #[doc = ""]
    #[doc = " In case of success, the pointer to the array is updated in order to"]
    #[doc = " point to the new grown array, and the number pointed to by `nb_ptr`"]
    #[doc = " is incremented."]
    #[doc = " In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and"]
    #[doc = " `*nb_ptr` is set to 0."]
    #[doc = ""]
    #[doc = " @param[in,out] tab_ptr Pointer to the array to grow"]
    #[doc = " @param[in,out] nb_ptr  Pointer to the number of elements in the array"]
    #[doc = " @param[in]     elem    Element to add"]
    #[doc = " @see av_dynarray_add_nofree(), av_dynarray2_add()"]
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[must_use]
    #[doc = " Add an element to a dynamic array."]
    #[doc = ""]
    #[doc = " Function has the same functionality as av_dynarray_add(),"]
    #[doc = " but it doesn't free memory on fails. It returns error code"]
    #[doc = " instead and leave current buffer untouched."]
    #[doc = ""]
    #[doc = " @return >=0 on success, negative otherwise"]
    #[doc = " @see av_dynarray_add(), av_dynarray2_add()"]
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an element of size `elem_size` to a dynamic array."]
    #[doc = ""]
    #[doc = " The array is reallocated when its number of elements reaches powers of 2."]
    #[doc = " Therefore, the amortized cost of adding an element is constant."]
    #[doc = ""]
    #[doc = " In case of success, the pointer to the array is updated in order to"]
    #[doc = " point to the new grown array, and the number pointed to by `nb_ptr`"]
    #[doc = " is incremented."]
    #[doc = " In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and"]
    #[doc = " `*nb_ptr` is set to 0."]
    #[doc = ""]
    #[doc = " @param[in,out] tab_ptr   Pointer to the array to grow"]
    #[doc = " @param[in,out] nb_ptr    Pointer to the number of elements in the array"]
    #[doc = " @param[in]     elem_size Size in bytes of an element in the array"]
    #[doc = " @param[in]     elem_data Pointer to the data of the element to add. If"]
    #[doc = "                          `NULL`, the space of the newly added element is"]
    #[doc = "                          allocated but left uninitialized."]
    #[doc = ""]
    #[doc = " @return Pointer to the data of the element to copy in the newly allocated"]
    #[doc = "         space"]
    #[doc = " @see av_dynarray_add(), av_dynarray_add_nofree()"]
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Set the maximum size that may be allocated in one block."]
    #[doc = ""]
    #[doc = " The value specified with this function is effective for all libavutil's @ref"]
    #[doc = " lavu_mem_funcs \"heap management functions.\""]
    #[doc = ""]
    #[doc = " By default, the max value is defined as `INT_MAX`."]
    #[doc = ""]
    #[doc = " @param max Value to be set as the new maximum size"]
    #[doc = ""]
    #[doc = " @warning Exercise extreme caution when using this function. Don't touch"]
    #[doc = "          this if you do not understand the full consequence of doing so."]
    pub fn av_max_alloc(max: usize);
}
#[doc = " Rational number (pair of numerator and denominator)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVRational {
    #[doc = "< Numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = "< Denominator"]
    pub den: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Reduce a fraction."]
    #[doc = ""]
    #[doc = " This is useful for framerate calculations."]
    #[doc = ""]
    #[doc = " @param[out] dst_num Destination numerator"]
    #[doc = " @param[out] dst_den Destination denominator"]
    #[doc = " @param[in]      num Source numerator"]
    #[doc = " @param[in]      den Source denominator"]
    #[doc = " @param[in]      max Maximum allowed values for `dst_num` & `dst_den`"]
    #[doc = " @return 1 if the operation is exact, 0 otherwise"]
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Multiply two rationals."]
    #[doc = " @param b First rational"]
    #[doc = " @param c Second rational"]
    #[doc = " @return b*c"]
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Divide one rational by another."]
    #[doc = " @param b First rational"]
    #[doc = " @param c Second rational"]
    #[doc = " @return b/c"]
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Add two rationals."]
    #[doc = " @param b First rational"]
    #[doc = " @param c Second rational"]
    #[doc = " @return b+c"]
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Subtract one rational from another."]
    #[doc = " @param b First rational"]
    #[doc = " @param c Second rational"]
    #[doc = " @return b-c"]
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Convert a double precision floating point number to a rational."]
    #[doc = ""]
    #[doc = " In case of infinity, the returned value is expressed as `{1, 0}` or"]
    #[doc = " `{-1, 0}` depending on the sign."]
    #[doc = ""]
    #[doc = " @param d   `double` to convert"]
    #[doc = " @param max Maximum allowed numerator and denominator"]
    #[doc = " @return `d` in AVRational form"]
    #[doc = " @see av_q2d()"]
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    #[doc = " Find which of the two rationals is closer to another rational."]
    #[doc = ""]
    #[doc = " @param q     Rational to be compared against"]
    #[doc = " @param q1,q2 Rationals to be tested"]
    #[doc = " @return One of the following values:"]
    #[doc = "         - 1 if `q1` is nearer to `q` than `q2`"]
    #[doc = "         - -1 if `q2` is nearer to `q` than `q1`"]
    #[doc = "         - 0 if they have the same distance"]
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the value in a list of rationals nearest a given reference rational."]
    #[doc = ""]
    #[doc = " @param q      Reference rational"]
    #[doc = " @param q_list Array of rationals terminated by `{0, 0}`"]
    #[doc = " @return Index of the nearest value found in the array"]
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point"]
    #[doc = " format."]
    #[doc = ""]
    #[doc = " @param q Rational to be converted"]
    #[doc = " @return Equivalent floating-point value, expressed as an unsigned 32-bit"]
    #[doc = "         integer."]
    #[doc = " @note The returned value is platform-indepedant."]
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
    #[doc = " Return the best rational so that a and b are multiple of it."]
    #[doc = " If the resulting denominator is larger than max_den, return def."]
    pub fn av_gcd_q(
        a: AVRational,
        b: AVRational,
        max_den: ::std::os::raw::c_int,
        def: AVRational,
    ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
    _bindgen_union_align: u32,
}
impl Default for av_intfloat32 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
    _bindgen_union_align: u64,
}
impl Default for av_intfloat64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "< Round toward zero."]
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
#[doc = "< Round away from zero."]
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
#[doc = "< Round toward -infinity."]
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
#[doc = "< Round toward +infinity."]
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
#[doc = "< Round to nearest and halfway cases away from zero."]
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
#[doc = " Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through"]
#[doc = " unchanged, avoiding special cases for #AV_NOPTS_VALUE."]
#[doc = ""]
#[doc = " Unlike other values of the enumeration AVRounding, this value is a"]
#[doc = " bitmask that must be used in conjunction with another value of the"]
#[doc = " enumeration through a bitwise OR, in order to set behavior for normal"]
#[doc = " cases."]
#[doc = ""]
#[doc = " @code{.c}"]
#[doc = " av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);"]
#[doc = " // Rescaling 3:"]
#[doc = " //     Calculating 3 * 1 / 2"]
#[doc = " //     3 / 2 is rounded up to 2"]
#[doc = " //     => 2"]
#[doc = ""]
#[doc = " av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);"]
#[doc = " // Rescaling AV_NOPTS_VALUE:"]
#[doc = " //     AV_NOPTS_VALUE == INT64_MIN"]
#[doc = " //     AV_NOPTS_VALUE is passed through"]
#[doc = " //     => AV_NOPTS_VALUE"]
#[doc = " @endcode"]
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
#[doc = " Rounding methods."]
pub type AVRounding = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Compute the greatest common divisor of two integer operands."]
    #[doc = ""]
    #[doc = " @param a,b Operands"]
    #[doc = " @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;"]
    #[doc = " if a == 0 and b == 0, returns 0."]
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with rounding to nearest."]
    #[doc = ""]
    #[doc = " The operation is mathematically equivalent to `a * b / c`, but writing that"]
    #[doc = " directly can overflow."]
    #[doc = ""]
    #[doc = " This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF."]
    #[doc = ""]
    #[doc = " @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with specified rounding."]
    #[doc = ""]
    #[doc = " The operation is mathematically equivalent to `a * b / c`, but writing that"]
    #[doc = " directly can overflow, and does not support different rounding methods."]
    #[doc = ""]
    #[doc = " @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers."]
    #[doc = ""]
    #[doc = " The operation is mathematically equivalent to `a * bq / cq`."]
    #[doc = ""]
    #[doc = " This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF."]
    #[doc = ""]
    #[doc = " @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()"]
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers with specified rounding."]
    #[doc = ""]
    #[doc = " The operation is mathematically equivalent to `a * bq / cq`."]
    #[doc = ""]
    #[doc = " @see av_rescale(), av_rescale_rnd(), av_rescale_q()"]
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Compare two timestamps each in its own time base."]
    #[doc = ""]
    #[doc = " @return One of the following values:"]
    #[doc = "         - -1 if `ts_a` is before `ts_b`"]
    #[doc = "         - 1 if `ts_a` is after `ts_b`"]
    #[doc = "         - 0 if they represent the same position"]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " The result of the function is undefined if one of the timestamps is outside"]
    #[doc = " the `int64_t` range when represented in the other's timebase."]
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the remainders of two integer operands divided by a common divisor."]
    #[doc = ""]
    #[doc = " In other words, compare the least significant `log2(mod)` bits of integers"]
    #[doc = " `a` and `b`."]
    #[doc = ""]
    #[doc = " @code{.c}"]
    #[doc = " av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)"]
    #[doc = " av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @param a,b Operands"]
    #[doc = " @param mod Divisor; must be a power of 2"]
    #[doc = " @return"]
    #[doc = "         - a negative value if `a % mod < b % mod`"]
    #[doc = "         - a positive value if `a % mod > b % mod`"]
    #[doc = "         - zero             if `a % mod == b % mod`"]
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    #[doc = " Rescale a timestamp while preserving known durations."]
    #[doc = ""]
    #[doc = " This function is designed to be called per audio packet to scale the input"]
    #[doc = " timestamp to a different time base. Compared to a simple av_rescale_q()"]
    #[doc = " call, this function is robust against possible inconsistent frame durations."]
    #[doc = ""]
    #[doc = " The `last` parameter is a state variable that must be preserved for all"]
    #[doc = " subsequent calls for the same stream. For the first call, `*last` should be"]
    #[doc = " initialized to #AV_NOPTS_VALUE."]
    #[doc = ""]
    #[doc = " @param[in]     in_tb    Input time base"]
    #[doc = " @param[in]     in_ts    Input timestamp"]
    #[doc = " @param[in]     fs_tb    Duration time base; typically this is finer-grained"]
    #[doc = "                         (greater) than `in_tb` and `out_tb`"]
    #[doc = " @param[in]     duration Duration till the next call to this function (i.e."]
    #[doc = "                         duration of the current packet/frame)"]
    #[doc = " @param[in,out] last     Pointer to a timestamp expressed in terms of"]
    #[doc = "                         `fs_tb`, acting as a state variable"]
    #[doc = " @param[in]     out_tb   Output timebase"]
    #[doc = " @return        Timestamp expressed in terms of `out_tb`"]
    #[doc = ""]
    #[doc = " @note In the context of this function, \"duration\" is in term of samples, not"]
    #[doc = "       seconds."]
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    #[doc = " Add a value to a timestamp."]
    #[doc = ""]
    #[doc = " This function guarantees that when the same value is repeatly added that"]
    #[doc = " no accumulation of rounding errors occurs."]
    #[doc = ""]
    #[doc = " @param[in] ts     Input timestamp"]
    #[doc = " @param[in] ts_tb  Input timestamp time base"]
    #[doc = " @param[in] inc    Value to be added"]
    #[doc = " @param[in] inc_tb Time base of `inc`"]
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub type __gnuc_va_list = __builtin_va_list;
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
#[doc = "< not part of ABI/API"]
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    _unused: [u8; 0],
}
#[doc = " Describe the class of an AVClass context structure. That is an"]
#[doc = " arbitrary struct of which the first field is a pointer to an"]
#[doc = " AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVClass {
    #[doc = " The name of the class; usually it is the same name as the"]
    #[doc = " context structure type to which the AVClass is associated."]
    pub class_name: *const ::std::os::raw::c_char,
    #[doc = " A pointer to a function which returns the name of a context"]
    #[doc = " instance ctx associated with the class."]
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " a pointer to the first option specified in the class if any or NULL"]
    #[doc = ""]
    #[doc = " @see av_set_default_options()"]
    pub option: *mut AVOption,
    #[doc = " LIBAVUTIL_VERSION with which this structure was created."]
    #[doc = " This is used to allow fields to be added without requiring major"]
    #[doc = " version bumps everywhere."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where log_level_offset is stored."]
    #[doc = " 0 means there is no such variable"]
    pub log_level_offset_offset: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where a pointer to the parent context for"]
    #[doc = " logging is stored. For example a decoder could pass its AVCodecContext"]
    #[doc = " to eval as such a parent context, which an av_log() implementation"]
    #[doc = " could then leverage to display the parent context."]
    #[doc = " The offset can be NULL."]
    pub parent_log_context_offset: ::std::os::raw::c_int,
    #[doc = " Return next AVOptions-enabled child or NULL"]
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Return an AVClass corresponding to the next potential"]
    #[doc = " AVOptions-enabled child."]
    #[doc = ""]
    #[doc = " The difference between child_next and this is that"]
    #[doc = " child_next iterates over _already existing_ objects, while"]
    #[doc = " child_class_next iterates over _all possible_ children."]
    pub child_class_next:
        ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    #[doc = " Category used for visualization (like color)"]
    #[doc = " This is only set if the category is equal for all objects using this class."]
    #[doc = " available since version (51 << 16 | 56 << 8 | 100)"]
    pub category: AVClassCategory,
    #[doc = " Callback to return the category."]
    #[doc = " available since version (51 << 16 | 59 << 8 | 100)"]
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    #[doc = " Callback to return the supported/allowed ranges."]
    #[doc = " available since version (52.12)"]
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled"]
    #[doc = " children."]
    #[doc = ""]
    #[doc = " @param iter pointer to opaque iteration state. The caller must initialize"]
    #[doc = "             *iter to NULL before the first call."]
    #[doc = " @return AVClass for the next AVOptions-enabled child or NULL if there are"]
    #[doc = "         no more such children."]
    #[doc = ""]
    #[doc = " @note The difference between child_next and this is that child_next"]
    #[doc = "       iterates over _already existing_ objects, while child_class_iterate"]
    #[doc = "       iterates over _all possible_ children."]
    pub child_class_iterate: ::std::option::Option<
        unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const AVClass,
    >,
}
impl Default for AVClass {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal"]
    #[doc = " to the current av_log_level. By default, all logging messages are sent to"]
    #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
    #[doc = " function."]
    #[doc = " @see av_log_set_callback"]
    #[doc = ""]
    #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
    #[doc = "        pointer to an AVClass struct or NULL if general log."]
    #[doc = " @param level The importance level of the message expressed using a @ref"]
    #[doc = "        lavu_log_constants \"Logging Constant\"."]
    #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
    #[doc = "        subsequent arguments are converted to output."]
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log once with the initial_level and then with"]
    #[doc = " the subsequent_level. By default, all logging messages are sent to"]
    #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
    #[doc = " function."]
    #[doc = " @see av_log"]
    #[doc = ""]
    #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
    #[doc = "        pointer to an AVClass struct or NULL if general log."]
    #[doc = " @param initial_level importance level of the message expressed using a @ref"]
    #[doc = "        lavu_log_constants \"Logging Constant\" for the first occurance."]
    #[doc = " @param subsequent_level importance level of the message expressed using a @ref"]
    #[doc = "        lavu_log_constants \"Logging Constant\" after the first occurance."]
    #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
    #[doc = "        subsequent arguments are converted to output."]
    #[doc = " @param state a variable to keep trak of if a message has already been printed"]
    #[doc = "        this must be initialized to 0 before the first use. The same state"]
    #[doc = "        must not be accessed by 2 Threads simultaneously."]
    pub fn av_log_once(
        avcl: *mut ::std::os::raw::c_void,
        initial_level: ::std::os::raw::c_int,
        subsequent_level: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal"]
    #[doc = " to the current av_log_level. By default, all logging messages are sent to"]
    #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
    #[doc = " function."]
    #[doc = " @see av_log_set_callback"]
    #[doc = ""]
    #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
    #[doc = "        pointer to an AVClass struct."]
    #[doc = " @param level The importance level of the message expressed using a @ref"]
    #[doc = "        lavu_log_constants \"Logging Constant\"."]
    #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
    #[doc = "        subsequent arguments are converted to output."]
    #[doc = " @param vl The arguments referenced by the format string."]
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    #[doc = " Get the current log level"]
    #[doc = ""]
    #[doc = " @see lavu_log_constants"]
    #[doc = ""]
    #[doc = " @return Current log level"]
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level"]
    #[doc = ""]
    #[doc = " @see lavu_log_constants"]
    #[doc = ""]
    #[doc = " @param level Logging level"]
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the logging callback"]
    #[doc = ""]
    #[doc = " @note The callback must be thread safe, even if the application does not use"]
    #[doc = "       threads itself as some codecs are multithreaded."]
    #[doc = ""]
    #[doc = " @see av_log_default_callback"]
    #[doc = ""]
    #[doc = " @param callback A logging function with a compatible signature."]
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: va_list,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Default logging callback"]
    #[doc = ""]
    #[doc = " It prints the message to stderr, optionally colorizing it."]
    #[doc = ""]
    #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
    #[doc = "        pointer to an AVClass struct."]
    #[doc = " @param level The importance level of the message expressed using a @ref"]
    #[doc = "        lavu_log_constants \"Logging Constant\"."]
    #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
    #[doc = "        subsequent arguments are converted to output."]
    #[doc = " @param vl The arguments referenced by the format string."]
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    #[doc = " Return the context name"]
    #[doc = ""]
    #[doc = " @param  ctx The AVClass context"]
    #[doc = ""]
    #[doc = " @return The AVClass class_name"]
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback."]
    #[doc = " @param line          buffer to receive the formatted line"]
    #[doc = " @param line_size     size of the buffer"]
    #[doc = " @param print_prefix  used to store whether the prefix must be printed;"]
    #[doc = "                      must point to a persistent integer initially set to 1"]
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback."]
    #[doc = " @param line          buffer to receive the formatted line;"]
    #[doc = "                      may be NULL if line_size is 0"]
    #[doc = " @param line_size     size of the buffer; at most line_size-1 characters will"]
    #[doc = "                      be written to the buffer, plus one null terminator"]
    #[doc = " @param print_prefix  used to store whether the prefix must be printed;"]
    #[doc = "                      must point to a persistent integer initially set to 1"]
    #[doc = " @return Returns a negative value if an error occurred, otherwise returns"]
    #[doc = "         the number of characters that would have been written for a"]
    #[doc = "         sufficiently large buffer, not including the terminating null"]
    #[doc = "         character. If the return value is not less than line_size, it means"]
    #[doc = "         that the log message was truncated to fit the buffer."]
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
#[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
#[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
#[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
#[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
#[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
#[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
#[doc = "<        Y        ,  8bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
#[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
#[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
#[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
#[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
#[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
#[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
#[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
#[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
#[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
#[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
#[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
#[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
#[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
#[doc = "<        Y        , 16bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
#[doc = "<        Y        , 16bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
#[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
#[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
#[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
#[doc = "< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 44;
#[doc = "< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 45;
#[doc = "< HW decoding through VA API, Picture.data[3] contains a VASurfaceID"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 46;
#[doc = "@}"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 46;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 47;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 48;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 49;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 50;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 51;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 52;
#[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 53;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 54;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 55;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 56;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 57;
#[doc = "< 8 bits gray, 8 bits alpha"]
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 58;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 58;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 58;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 59;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 60;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 61;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 62;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 63;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 64;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 65;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 66;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 67;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 68;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 69;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 70;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 71;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 72;
#[doc = "< planar GBR 4:4:4 24bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 73;
#[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 74;
#[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 75;
#[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 76;
#[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 77;
#[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 78;
#[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 79;
#[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 80;
#[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 81;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 82;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 83;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 84;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 85;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 86;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 87;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 88;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 89;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 90;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 91;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 92;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 93;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 94;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 95;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 96;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 97;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 98;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 99;
#[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 100;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 101;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 102;
#[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 103;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 104;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 105;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 106;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 107;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 108;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 109;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 110;
#[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 111;
#[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 112;
#[doc = "< planar GBRA 4:4:4:4 32bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 113;
#[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 114;
#[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 115;
#[doc = "  HW acceleration through QSV, data[3] contains a pointer to the"]
#[doc = "  mfxFrameSurface1 structure."]
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 116;
#[doc = " HW acceleration though MMAL, data[3] contains a pointer to the"]
#[doc = " MMAL_BUFFER_HEADER_T structure."]
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 117;
#[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 118;
#[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers"]
#[doc = " exactly as for system memory frames."]
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 119;
#[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 120;
#[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 121;
#[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 122;
#[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 123;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 124;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 125;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 126;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 127;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 128;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 129;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 130;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 131;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 132;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 133;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 134;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 135;
#[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 136;
#[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 137;
#[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 138;
#[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 139;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 140;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 141;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 142;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 143;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 144;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 145;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 146;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 147;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 148;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 149;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 150;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 151;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 152;
#[doc = "< XVideo Motion Acceleration via common packet passing"]
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 153;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 154;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 155;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 156;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 157;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 158;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 159;
#[doc = "< hardware decoding through Videotoolbox"]
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 160;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 161;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 162;
#[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 163;
#[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 164;
#[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 165;
#[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 166;
#[doc = "< hardware decoding through MediaCodec"]
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 167;
#[doc = "<        Y        , 12bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 168;
#[doc = "<        Y        , 12bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 169;
#[doc = "<        Y        , 10bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 170;
#[doc = "<        Y        , 10bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 171;
#[doc = "< like NV12, with 16bpp per component, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 172;
#[doc = "< like NV12, with 16bpp per component, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 173;
#[doc = " Hardware surfaces for Direct3D11."]
#[doc = ""]
#[doc = " This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11"]
#[doc = " hwaccel API and filtering support AV_PIX_FMT_D3D11 only."]
#[doc = ""]
#[doc = " data[0] contains a ID3D11Texture2D pointer, and data[1] contains the"]
#[doc = " texture array index of the frame as intptr_t if the ID3D11Texture2D is"]
#[doc = " an array texture (or always 0 if it's a normal texture)."]
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 174;
#[doc = "<        Y        , 9bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 175;
#[doc = "<        Y        , 9bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 176;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 177;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 178;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 179;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 180;
#[doc = " DRM-managed buffers exposed through PRIME buffer sharing."]
#[doc = ""]
#[doc = " data[0] points to an AVDRMFrameDescriptor."]
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 181;
#[doc = " Hardware surfaces for OpenCL."]
#[doc = ""]
#[doc = " data[i] contain 2D image objects (typed in C as cl_mem, used"]
#[doc = " in OpenCL as image2d_t) for each plane of the surface."]
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 182;
#[doc = "<        Y        , 14bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: AVPixelFormat = 183;
#[doc = "<        Y        , 14bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: AVPixelFormat = 184;
#[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 185;
#[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 186;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 187;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 188;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 189;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 190;
#[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV24: AVPixelFormat = 191;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV42: AVPixelFormat = 192;
#[doc = " Vulkan hardware images."]
#[doc = ""]
#[doc = " data[0] points to an AVVkFrame"]
pub const AVPixelFormat_AV_PIX_FMT_VULKAN: AVPixelFormat = 193;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210BE: AVPixelFormat = 194;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210LE: AVPixelFormat = 195;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10LE: AVPixelFormat = 196;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10BE: AVPixelFormat = 197;
#[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 198;
#[doc = " Pixel format."]
#[doc = ""]
#[doc = " @note"]
#[doc = " AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA"]
#[doc = " color is put together as:"]
#[doc = "  (A << 24) | (R << 16) | (G << 8) | B"]
#[doc = " This is stored as BGRA on little-endian CPU architectures and ARGB on"]
#[doc = " big-endian CPUs."]
#[doc = ""]
#[doc = " @note"]
#[doc = " If the resolution is not a multiple of the chroma subsampling factor"]
#[doc = " then the chroma plane resolution must be rounded up."]
#[doc = ""]
#[doc = " @par"]
#[doc = " When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized"]
#[doc = " image data is stored in AVFrame.data[0]. The palette is transported in"]
#[doc = " AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is"]
#[doc = " formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is"]
#[doc = " also endian-specific). Note also that the individual RGB32 palette"]
#[doc = " components stored in AVFrame.data[1] should be in the range 0..255."]
#[doc = " This is important as many custom PAL8 video codecs that were designed"]
#[doc = " to run on the IBM VGA graphics adapter use 6-bit palette components."]
#[doc = ""]
#[doc = " @par"]
#[doc = " For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like"]
#[doc = " for pal8. This palette is filled in automatically by the function"]
#[doc = " allocating the picture."]
pub type AVPixelFormat = ::std::os::raw::c_int;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B"]
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
#[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
#[doc = "< functionally identical to above"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
#[doc = "< colour filters using Illuminant C"]
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
#[doc = "< ITU-R BT2020"]
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
#[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
#[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
#[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
#[doc = "< EBU Tech. 3213-E / JEDEC P22 phosphors"]
pub const AVColorPrimaries_AVCOL_PRI_EBU3213: AVColorPrimaries = 22;
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
#[doc = "< Not part of ABI"]
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
#[doc = " Chromaticity coordinates of the source primaries."]
#[doc = " These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1."]
pub type AVColorPrimaries = ::std::os::raw::c_uint;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
#[doc = "< also ITU-R BT1361"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
#[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
#[doc = "< also ITU-R BT470BG"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
#[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
#[doc = "< \"Linear transfer characteristics\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
#[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
#[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
#[doc = "< IEC 61966-2-4"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
#[doc = "< ITU-R BT1361 Extended Colour Gamut"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
#[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
#[doc = "< ITU-R BT2020 for 10-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
#[doc = "< ITU-R BT2020 for 12-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
#[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
#[doc = "< SMPTE ST 428-1"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
#[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
#[doc = "< Not part of ABI"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
#[doc = " Color Transfer Characteristic."]
#[doc = " These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2."]
pub type AVColorTransferCharacteristic = ::std::os::raw::c_uint;
#[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)"]
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B"]
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
#[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
#[doc = "< functionally identical to above"]
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
#[doc = "< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
#[doc = "< ITU-R BT2020 non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
#[doc = "< ITU-R BT2020 constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
#[doc = "< SMPTE 2085, Y'D'zD'x"]
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
#[doc = "< Chromaticity-derived non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
#[doc = "< Chromaticity-derived constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
#[doc = "< ITU-R BT.2100-0, ICtCp"]
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
#[doc = "< Not part of ABI"]
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 15;
#[doc = " YUV colorspace type."]
#[doc = " These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3."]
pub type AVColorSpace = ::std::os::raw::c_uint;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
#[doc = " Narrow or limited range content."]
#[doc = ""]
#[doc = " - For luminance planes:"]
#[doc = ""]
#[doc = "       (219 * E + 16) * 2^(n-8)"]
#[doc = ""]
#[doc = "   F.ex. the range of 16-235 for 8 bits"]
#[doc = ""]
#[doc = " - For chrominance planes:"]
#[doc = ""]
#[doc = "       (224 * E + 128) * 2^(n-8)"]
#[doc = ""]
#[doc = "   F.ex. the range of 16-240 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
#[doc = " Full range content."]
#[doc = ""]
#[doc = " - For RGB and luminance planes:"]
#[doc = ""]
#[doc = "       (2^n - 1) * E"]
#[doc = ""]
#[doc = "   F.ex. the range of 0-255 for 8 bits"]
#[doc = ""]
#[doc = " - For chrominance planes:"]
#[doc = ""]
#[doc = "       (2^n - 1) * E + 2^(n - 1)"]
#[doc = ""]
#[doc = "   F.ex. the range of 1-255 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
#[doc = "< Not part of ABI"]
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
#[doc = " Visual content value range."]
#[doc = ""]
#[doc = " These values are based on definitions that can be found in multiple"]
#[doc = " specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance"]
#[doc = " and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital"]
#[doc = " Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit"]
#[doc = " integer representation). At the time of writing, the BT.2100 one is"]
#[doc = " recommended, as it also defines the full range representation."]
#[doc = ""]
#[doc = " Common definitions:"]
#[doc = "   - For RGB and luminance planes such as Y in YCbCr and I in ICtCp,"]
#[doc = "     'E' is the original value in range of 0.0 to 1.0."]
#[doc = "   - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original"]
#[doc = "     value in range of -0.5 to 0.5."]
#[doc = "   - 'n' is the output bit depth."]
#[doc = "   - For additional definitions such as rounding and clipping to valid n"]
#[doc = "     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
pub type AVColorRange = ::std::os::raw::c_uint;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
#[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
#[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
#[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
#[doc = "< Not part of ABI"]
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
#[doc = " Location of chroma samples."]
#[doc = ""]
#[doc = " Illustration showing the location of the first (top left) chroma sample of the"]
#[doc = " image, the left shows only luma, the right"]
#[doc = " shows the location of the chroma sample, the 2 could be imagined to overlay"]
#[doc = " each other but are drawn separately due to limitations of ASCII"]
#[doc = ""]
#[doc = "                1st 2nd       1st 2nd horizontal luma sample positions"]
#[doc = "                 v   v         v   v"]
#[doc = "                 ______        ______"]
#[doc = "1st luma line > |X   X ...    |3 4 X ...     X are luma samples,"]
#[doc = "                |             |1 2           1-6 are possible chroma positions"]
#[doc = "2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
pub type AVChromaLocation = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Compute the length of an integer list."]
    #[doc = ""]
    #[doc = " @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)"]
    #[doc = " @param term    list terminator (usually 0 or -1)"]
    #[doc = " @param list    pointer to the list"]
    #[doc = " @return  length of the list, in elements, not counting the terminator"]
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Open a file using a UTF-8 filename."]
    #[doc = " The API of this function matches POSIX fopen(), errors are returned through"]
    #[doc = " errno."]
    pub fn av_fopen_utf8(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Return the fractional representation of the internal time base."]
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    #[doc = " Fill the provided buffer with a string containing a FourCC (four-character"]
    #[doc = " code) representation."]
    #[doc = ""]
    #[doc = " @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE"]
    #[doc = " @param fourcc the fourcc to represent"]
    #[doc = " @return the buffer in input"]
    pub fn av_fourcc_make_string(
        buf: *mut ::std::os::raw::c_char,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[doc = " A reference to a data buffer."]
#[doc = ""]
#[doc = " The size of this struct is not a part of the public ABI and it is not meant"]
#[doc = " to be allocated directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    #[doc = " The data buffer. It is considered writable if and only if"]
    #[doc = " this is the only reference to the buffer, in which case"]
    #[doc = " av_buffer_is_writable() returns 1."]
    pub data: *mut u8,
    #[doc = " Size of data in bytes."]
    pub size: ::std::os::raw::c_int,
}
impl Default for AVBufferRef {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Allocate an AVBuffer of the given size using av_malloc()."]
    #[doc = ""]
    #[doc = " @return an AVBufferRef of given size or NULL when out of memory"]
    pub fn av_buffer_alloc(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Same as av_buffer_alloc(), except the returned buffer will be initialized"]
    #[doc = " to zero."]
    pub fn av_buffer_allocz(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Create an AVBuffer from an existing array."]
    #[doc = ""]
    #[doc = " If this function is successful, data is owned by the AVBuffer. The caller may"]
    #[doc = " only access data through the returned AVBufferRef and references derived from"]
    #[doc = " it."]
    #[doc = " If this function fails, data is left untouched."]
    #[doc = " @param data   data array"]
    #[doc = " @param size   size of data in bytes"]
    #[doc = " @param free   a callback for freeing this buffer's data"]
    #[doc = " @param opaque parameter to be got for processing or passed to free"]
    #[doc = " @param flags  a combination of AV_BUFFER_FLAG_*"]
    #[doc = ""]
    #[doc = " @return an AVBufferRef referring to data on success, NULL on failure."]
    pub fn av_buffer_create(
        data: *mut u8,
        size: ::std::os::raw::c_int,
        free: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
        >,
        opaque: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Default free callback, which calls av_free() on the buffer data."]
    #[doc = " This function is meant to be passed to av_buffer_create(), not called"]
    #[doc = " directly."]
    pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
    #[doc = " Create a new reference to an AVBuffer."]
    #[doc = ""]
    #[doc = " @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on"]
    #[doc = " failure."]
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Free a given reference and automatically free the buffer if there are no more"]
    #[doc = " references to it."]
    #[doc = ""]
    #[doc = " @param buf the reference to be freed. The pointer is set to NULL on return."]
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    #[doc = " @return 1 if the caller may write to the data referred to by buf (which is"]
    #[doc = " true if and only if buf is the only reference to the underlying AVBuffer)."]
    #[doc = " Return 0 otherwise."]
    #[doc = " A positive answer is valid until av_buffer_ref() is called on buf."]
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the opaque parameter set by av_buffer_create."]
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a writable reference from a given buffer reference, avoiding data copy"]
    #[doc = " if possible."]
    #[doc = ""]
    #[doc = " @param buf buffer reference to make writable. On success, buf is either left"]
    #[doc = "            untouched, or it is unreferenced and a new writable AVBufferRef is"]
    #[doc = "            written in its place. On failure, buf is left untouched."]
    #[doc = " @return 0 on success, a negative AVERROR on failure."]
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reallocate a given buffer."]
    #[doc = ""]
    #[doc = " @param buf  a buffer reference to reallocate. On success, buf will be"]
    #[doc = "             unreferenced and a new reference with the required size will be"]
    #[doc = "             written in its place. On failure buf will be left untouched. *buf"]
    #[doc = "             may be NULL, then a new buffer is allocated."]
    #[doc = " @param size required new buffer size."]
    #[doc = " @return 0 on success, a negative AVERROR on failure."]
    #[doc = ""]
    #[doc = " @note the buffer is actually reallocated with av_realloc() only if it was"]
    #[doc = " initially allocated through av_buffer_realloc(NULL) and there is only one"]
    #[doc = " reference to it (i.e. the one passed to this function). In all other cases"]
    #[doc = " a new buffer is allocated and the data is copied."]
    pub fn av_buffer_realloc(
        buf: *mut *mut AVBufferRef,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure dst refers to the same data as src."]
    #[doc = ""]
    #[doc = " When *dst is already equivalent to src, do nothing. Otherwise unreference dst"]
    #[doc = " and replace it with a new reference to src."]
    #[doc = ""]
    #[doc = " @param dst Pointer to either a valid buffer reference or NULL. On success,"]
    #[doc = "            this will point to a buffer reference equivalent to src. On"]
    #[doc = "            failure, dst will be left untouched."]
    #[doc = " @param src A buffer reference to replace dst with. May be NULL, then this"]
    #[doc = "            function is equivalent to av_buffer_unref(dst)."]
    #[doc = " @return 0 on success"]
    #[doc = "         AVERROR(ENOMEM) on memory allocation failure."]
    pub fn av_buffer_replace(
        dst: *mut *mut AVBufferRef,
        src: *mut AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize a buffer pool."]
    #[doc = ""]
    #[doc = " @param size size of each buffer in this pool"]
    #[doc = " @param alloc a function that will be used to allocate new buffers when the"]
    #[doc = " pool is empty. May be NULL, then the default allocator will be used"]
    #[doc = " (av_buffer_alloc())."]
    #[doc = " @return newly created buffer pool on success, NULL on error."]
    pub fn av_buffer_pool_init(
        size: ::std::os::raw::c_int,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(size: ::std::os::raw::c_int) -> *mut AVBufferRef,
        >,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Allocate and initialize a buffer pool with a more complex allocator."]
    #[doc = ""]
    #[doc = " @param size size of each buffer in this pool"]
    #[doc = " @param opaque arbitrary user data used by the allocator"]
    #[doc = " @param alloc a function that will be used to allocate new buffers when the"]
    #[doc = "              pool is empty. May be NULL, then the default allocator will be"]
    #[doc = "              used (av_buffer_alloc())."]
    #[doc = " @param pool_free a function that will be called immediately before the pool"]
    #[doc = "                  is freed. I.e. after av_buffer_pool_uninit() is called"]
    #[doc = "                  by the caller and all the frames are returned to the pool"]
    #[doc = "                  and freed. It is intended to uninitialize the user opaque"]
    #[doc = "                  data. May be NULL."]
    #[doc = " @return newly created buffer pool on success, NULL on error."]
    pub fn av_buffer_pool_init2(
        size: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                size: ::std::os::raw::c_int,
            ) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Mark the pool as being available for freeing. It will actually be freed only"]
    #[doc = " once all the allocated buffers associated with the pool are released. Thus it"]
    #[doc = " is safe to call this function while some of the allocated buffers are still"]
    #[doc = " in use."]
    #[doc = ""]
    #[doc = " @param pool pointer to the pool to be freed. It will be set to NULL."]
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    #[doc = " Allocate a new AVBuffer, reusing an old buffer from the pool when available."]
    #[doc = " This function may be called simultaneously from multiple threads."]
    #[doc = ""]
    #[doc = " @return a reference to the new buffer on success, NULL on error."]
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Query the original opaque parameter of an allocated buffer in the pool."]
    #[doc = ""]
    #[doc = " @param ref a buffer reference to a buffer returned by av_buffer_pool_get."]
    #[doc = " @return the opaque parameter set by the buffer allocator function of the"]
    #[doc = "         buffer pool."]
    #[doc = ""]
    #[doc = " @note the opaque parameter of ref is used by the buffer pool implementation,"]
    #[doc = " therefore you have to use this function to access the original opaque"]
    #[doc = " parameter of an allocated buffer."]
    pub fn av_buffer_pool_buffer_get_opaque(ref_: *mut AVBufferRef) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVDictionaryEntry {
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
impl Default for AVDictionaryEntry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a dictionary entry with matching key."]
    #[doc = ""]
    #[doc = " The returned entry key or value must not be changed, or it will"]
    #[doc = " cause undefined behavior."]
    #[doc = ""]
    #[doc = " To iterate through all the dictionary entries, you can set the matching key"]
    #[doc = " to the null string \"\" and set the AV_DICT_IGNORE_SUFFIX flag."]
    #[doc = ""]
    #[doc = " @param prev Set to the previous matching element to find the next."]
    #[doc = "             If set to NULL the first matching element is returned."]
    #[doc = " @param key matching key"]
    #[doc = " @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved"]
    #[doc = " @return found entry or NULL in case no matching entry was found in the dictionary"]
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const ::std::os::raw::c_char,
        prev: *const AVDictionaryEntry,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    #[doc = " Get number of entries in dictionary."]
    #[doc = ""]
    #[doc = " @param m dictionary"]
    #[doc = " @return  number of entries in dictionary"]
    pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the given entry in *pm, overwriting an existing entry."]
    #[doc = ""]
    #[doc = " Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,"]
    #[doc = " these arguments will be freed on error."]
    #[doc = ""]
    #[doc = " Warning: Adding a new entry to a dictionary invalidates all existing entries"]
    #[doc = " previously returned with av_dict_get."]
    #[doc = ""]
    #[doc = " @param pm pointer to a pointer to a dictionary struct. If *pm is NULL"]
    #[doc = " a dictionary struct is allocated and put in *pm."]
    #[doc = " @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)"]
    #[doc = " @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags)."]
    #[doc = "        Passing a NULL value will cause an existing entry to be deleted."]
    #[doc = " @return >= 0 on success otherwise an error code <0"]
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience wrapper for av_dict_set that converts the value to a string"]
    #[doc = " and stores it."]
    #[doc = ""]
    #[doc = " Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error."]
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse the key/value pairs list and add the parsed entries to a dictionary."]
    #[doc = ""]
    #[doc = " In case of failure, all the successfully set entries are stored in"]
    #[doc = " *pm. You may need to manually free the created dictionary."]
    #[doc = ""]
    #[doc = " @param key_val_sep  a 0-terminated list of characters used to separate"]
    #[doc = "                     key from value"]
    #[doc = " @param pairs_sep    a 0-terminated list of characters used to separate"]
    #[doc = "                     two pairs from each other"]
    #[doc = " @param flags        flags to use when adding to dictionary."]
    #[doc = "                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL"]
    #[doc = "                     are ignored since the key/value tokens will always"]
    #[doc = "                     be duplicated."]
    #[doc = " @return             0 on success, negative AVERROR code on failure"]
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str_: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy entries from one AVDictionary struct into another."]
    #[doc = " @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,"]
    #[doc = "            this function will allocate a struct for you and put it in *dst"]
    #[doc = " @param src pointer to source AVDictionary struct"]
    #[doc = " @param flags flags to use when setting entries in *dst"]
    #[doc = " @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag"]
    #[doc = " @return 0 on success, negative AVERROR code on failure. If dst was allocated"]
    #[doc = "           by this function, callers should free the associated memory."]
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all the memory allocated for an AVDictionary struct"]
    #[doc = " and all keys and values."]
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    #[doc = " Get dictionary entries as a string."]
    #[doc = ""]
    #[doc = " Create a string containing dictionary's entries."]
    #[doc = " Such string may be passed back to av_dict_parse_string()."]
    #[doc = " @note String is escaped with backslashes ('\\')."]
    #[doc = ""]
    #[doc = " @param[in]  m             dictionary"]
    #[doc = " @param[out] buffer        Pointer to buffer that will be allocated with string containg entries."]
    #[doc = "                           Buffer must be freed by the caller when is no longer needed."]
    #[doc = " @param[in]  key_val_sep   character used to separate key from value"]
    #[doc = " @param[in]  pairs_sep     character used to separate two pairs from each other"]
    #[doc = " @return                   >= 0 on success, negative on error"]
    #[doc = " @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
#[doc = "< unsigned 8 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
#[doc = "< signed 16 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
#[doc = "< signed 32 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
#[doc = "< float"]
pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
#[doc = "< double"]
pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
#[doc = "< unsigned 8 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
#[doc = "< signed 16 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
#[doc = "< signed 32 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
#[doc = "< float, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
#[doc = "< double, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
#[doc = "< signed 64 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
#[doc = "< signed 64 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
#[doc = "< Number of sample formats. DO NOT USE if linking dynamically"]
pub const AVSampleFormat_AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
#[doc = " Audio sample formats"]
#[doc = ""]
#[doc = " - The data described by the sample format is always in native-endian order."]
#[doc = "   Sample values can be expressed by native C types, hence the lack of a signed"]
#[doc = "   24-bit sample format even though it is a common raw audio data format."]
#[doc = ""]
#[doc = " - The floating-point formats are based on full volume being in the range"]
#[doc = "   [-1.0, 1.0]. Any values outside this range are beyond full volume level."]
#[doc = ""]
#[doc = " - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg"]
#[doc = "   (such as AVFrame in libavcodec) is as follows:"]
#[doc = ""]
#[doc = " @par"]
#[doc = " For planar sample formats, each audio channel is in a separate data plane,"]
#[doc = " and linesize is the buffer size, in bytes, for a single plane. All data"]
#[doc = " planes must be the same size. For packed sample formats, only the first data"]
#[doc = " plane is used, and samples for each channel are interleaved. In this case,"]
#[doc = " linesize is the buffer size, in bytes, for the 1 plane."]
#[doc = ""]
pub type AVSampleFormat = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Return the name of sample_fmt, or NULL if sample_fmt is not"]
    #[doc = " recognized."]
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE"]
    #[doc = " on error."]
    pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Return the planar<->packed alternative form of the given sample format, or"]
    #[doc = " AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the"]
    #[doc = " requested planar/packed format, the format returned is the same as the"]
    #[doc = " input."]
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: ::std::os::raw::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the packed alternative form of the given sample format."]
    #[doc = ""]
    #[doc = " If the passed sample_fmt is already in packed format, the format returned is"]
    #[doc = " the same as the input."]
    #[doc = ""]
    #[doc = " @return  the packed alternative form of the given sample format or"]
    #[doc = "AV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the planar alternative form of the given sample format."]
    #[doc = ""]
    #[doc = " If the passed sample_fmt is already in planar format, the format returned is"]
    #[doc = " the same as the input."]
    #[doc = ""]
    #[doc = " @return  the planar alternative form of the given sample format or"]
    #[doc = "AV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Generate a string corresponding to the sample format with"]
    #[doc = " sample_fmt, or a header if sample_fmt is negative."]
    #[doc = ""]
    #[doc = " @param buf the buffer where to write the string"]
    #[doc = " @param buf_size the size of buf"]
    #[doc = " @param sample_fmt the number of the sample format to print the"]
    #[doc = " corresponding info string, or a negative value to print the"]
    #[doc = " corresponding header."]
    #[doc = " @return the pointer to the filled buffer or NULL if sample_fmt is"]
    #[doc = " unknown or in case of other errors"]
    pub fn av_get_sample_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return number of bytes per sample."]
    #[doc = ""]
    #[doc = " @param sample_fmt the sample format"]
    #[doc = " @return number of bytes per sample or zero if unknown for the given"]
    #[doc = " sample format"]
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the sample format is planar."]
    #[doc = ""]
    #[doc = " @param sample_fmt the sample format to inspect"]
    #[doc = " @return 1 if the sample format is planar, 0 if it is interleaved"]
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the required buffer size for the given audio parameters."]
    #[doc = ""]
    #[doc = " @param[out] linesize calculated linesize, may be NULL"]
    #[doc = " @param nb_channels   the number of channels"]
    #[doc = " @param nb_samples    the number of samples in a single channel"]
    #[doc = " @param sample_fmt    the sample format"]
    #[doc = " @param align         buffer size alignment (0 = default, 1 = no alignment)"]
    #[doc = " @return              required buffer size, or negative error code on failure"]
    pub fn av_samples_get_buffer_size(
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers and linesize for samples with sample"]
    #[doc = " format sample_fmt."]
    #[doc = ""]
    #[doc = " The audio_data array is filled with the pointers to the samples data planes:"]
    #[doc = " for planar, set the start point of each channel's data within the buffer,"]
    #[doc = " for packed, set the start point of the entire buffer only."]
    #[doc = ""]
    #[doc = " The value pointed to by linesize is set to the aligned size of each"]
    #[doc = " channel's data buffer for planar layout, or to the aligned size of the"]
    #[doc = " buffer for all channels for packed layout."]
    #[doc = ""]
    #[doc = " The buffer in buf must be big enough to contain all the samples"]
    #[doc = " (use av_samples_get_buffer_size() to compute its minimum size),"]
    #[doc = " otherwise the audio_data pointers will point to invalid data."]
    #[doc = ""]
    #[doc = " @see enum AVSampleFormat"]
    #[doc = " The documentation for AVSampleFormat describes the data layout."]
    #[doc = ""]
    #[doc = " @param[out] audio_data  array to be filled with the pointer for each channel"]
    #[doc = " @param[out] linesize    calculated linesize, may be NULL"]
    #[doc = " @param buf              the pointer to a buffer containing the samples"]
    #[doc = " @param nb_channels      the number of channels"]
    #[doc = " @param nb_samples       the number of samples in a single channel"]
    #[doc = " @param sample_fmt       the sample format"]
    #[doc = " @param align            buffer size alignment (0 = default, 1 = no alignment)"]
    #[doc = " @return                 >=0 on success or a negative error code on failure"]
    #[doc = " @todo return minimum size in bytes required for the buffer in case"]
    #[doc = " of success at the next bump"]
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        buf: *const u8,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a samples buffer for nb_samples samples, and fill data pointers and"]
    #[doc = " linesize accordingly."]
    #[doc = " The allocated samples buffer can be freed by using av_freep(&audio_data[0])"]
    #[doc = " Allocated data will be initialized to silence."]
    #[doc = ""]
    #[doc = " @see enum AVSampleFormat"]
    #[doc = " The documentation for AVSampleFormat describes the data layout."]
    #[doc = ""]
    #[doc = " @param[out] audio_data  array to be filled with the pointer for each channel"]
    #[doc = " @param[out] linesize    aligned size for audio buffer(s), may be NULL"]
    #[doc = " @param nb_channels      number of audio channels"]
    #[doc = " @param nb_samples       number of samples per channel"]
    #[doc = " @param align            buffer size alignment (0 = default, 1 = no alignment)"]
    #[doc = " @return                 >=0 on success or a negative error code on failure"]
    #[doc = " @todo return the size of the allocated buffer in case of success at the next bump"]
    #[doc = " @see av_samples_fill_arrays()"]
    #[doc = " @see av_samples_alloc_array_and_samples()"]
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a data pointers array, samples buffer for nb_samples"]
    #[doc = " samples, and fill data pointers and linesize accordingly."]
    #[doc = ""]
    #[doc = " This is the same as av_samples_alloc(), but also allocates the data"]
    #[doc = " pointers array."]
    #[doc = ""]
    #[doc = " @see av_samples_alloc()"]
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy samples from src to dst."]
    #[doc = ""]
    #[doc = " @param dst destination array of pointers to data planes"]
    #[doc = " @param src source array of pointers to data planes"]
    #[doc = " @param dst_offset offset in samples at which the data will be written to dst"]
    #[doc = " @param src_offset offset in samples at which the data will be read from src"]
    #[doc = " @param nb_samples number of samples to be copied"]
    #[doc = " @param nb_channels number of audio channels"]
    #[doc = " @param sample_fmt audio sample format"]
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *mut u8,
        dst_offset: ::std::os::raw::c_int,
        src_offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill an audio buffer with silence."]
    #[doc = ""]
    #[doc = " @param audio_data  array of pointers to data planes"]
    #[doc = " @param offset      offset in samples at which to start filling"]
    #[doc = " @param nb_samples  number of samples to fill"]
    #[doc = " @param nb_channels number of audio channels"]
    #[doc = " @param sample_fmt  audio sample format"]
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The data is the AVPanScan struct defined in libavcodec."]
pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
#[doc = " ATSC A53 Part 4 Closed Captions."]
#[doc = " A53 CC bitstream is stored as uint8_t in AVFrameSideData.data."]
#[doc = " The number of bytes of CC data is AVFrameSideData.size."]
pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
#[doc = " Stereoscopic 3d metadata."]
#[doc = " The data is the AVStereo3D struct defined in libavutil/stereo3d.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
#[doc = " The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
#[doc = " Metadata relevant to a downmix procedure."]
#[doc = " The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
#[doc = " ReplayGain information in the form of the AVReplayGain struct."]
pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
#[doc = " This side data contains a 3x3 transformation matrix describing an affine"]
#[doc = " transformation that needs to be applied to the frame for correct"]
#[doc = " presentation."]
#[doc = ""]
#[doc = " See libavutil/display.h for a detailed description of the data."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
#[doc = " Active Format Description data consisting of a single byte as specified"]
#[doc = " in ETSI TS 101 154 using AVActiveFormatDescription enum."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
#[doc = " Motion vectors exported by some codecs (on demand through the export_mvs"]
#[doc = " flag set in the libavcodec AVCodecContext flags2 option)."]
#[doc = " The data is the AVMotionVector struct defined in"]
#[doc = " libavutil/motion_vector.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
#[doc = " Recommmends skipping the specified number of samples. This is exported"]
#[doc = " only if the \"skip_manual\" AVOption is set in libavcodec."]
#[doc = " This has the same format as AV_PKT_DATA_SKIP_SAMPLES."]
#[doc = " @code"]
#[doc = " u32le number of samples to skip from start of this packet"]
#[doc = " u32le number of samples to skip from end of this packet"]
#[doc = " u8    reason for start skip"]
#[doc = " u8    reason for end   skip (0=padding silence, 1=convergence)"]
#[doc = " @endcode"]
pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
#[doc = " This side data must be associated with an audio frame and corresponds to"]
#[doc = " enum AVAudioServiceType defined in avcodec.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
#[doc = " Mastering display metadata associated with a video frame. The payload is"]
#[doc = " an AVMasteringDisplayMetadata type and contains information about the"]
#[doc = " mastering display color volume."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
#[doc = " The GOP timecode in 25 bit timecode format. Data format is 64-bit integer."]
#[doc = " This is set on the first frame of a GOP that has a temporal reference of 0."]
pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
#[doc = " The data represents the AVSphericalMapping structure defined in"]
#[doc = " libavutil/spherical.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
#[doc = " Content light level (based on CTA-861.3). This payload contains data in"]
#[doc = " the form of the AVContentLightMetadata struct."]
pub const AVFrameSideDataType_AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
#[doc = " The data contains an ICC profile as an opaque octet buffer following the"]
#[doc = " format described by ISO 15076-1 with an optional name defined in the"]
#[doc = " metadata key entry \"name\"."]
pub const AVFrameSideDataType_AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
#[doc = " Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA."]
#[doc = " The contents of this side data are undocumented and internal; use"]
#[doc = " av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a"]
#[doc = " meaningful way instead."]
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_PROPERTIES: AVFrameSideDataType = 16;
#[doc = " Raw QP table data. Its format is described by"]
#[doc = " AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and"]
#[doc = " av_frame_get_qp_table() to access this instead."]
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_DATA: AVFrameSideDataType = 17;
#[doc = " Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t"]
#[doc = " where the first uint32_t describes how many (1-3) of the other timecodes are used."]
#[doc = " The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()"]
#[doc = " function in libavutil/timecode.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 18;
#[doc = " HDR dynamic metadata associated with a video frame. The payload is"]
#[doc = " an AVDynamicHDRPlus type and contains information for color"]
#[doc = " volume transform - application 4 of SMPTE 2094-40:2016 standard."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DYNAMIC_HDR_PLUS: AVFrameSideDataType = 19;
#[doc = " Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of"]
#[doc = " array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size."]
pub const AVFrameSideDataType_AV_FRAME_DATA_REGIONS_OF_INTEREST: AVFrameSideDataType = 20;
#[doc = " Encoding parameters for a video frame, as described by AVVideoEncParams."]
pub const AVFrameSideDataType_AV_FRAME_DATA_VIDEO_ENC_PARAMS: AVFrameSideDataType = 21;
#[doc = " User data unregistered metadata associated with a video frame."]
#[doc = " This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose"]
#[doc = " The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of"]
#[doc = " uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte."]
pub const AVFrameSideDataType_AV_FRAME_DATA_SEI_UNREGISTERED: AVFrameSideDataType = 22;
#[doc = " Film grain parameters for a frame, described by AVFilmGrainParams."]
#[doc = " Must be present for every frame which should have film grain applied."]
pub const AVFrameSideDataType_AV_FRAME_DATA_FILM_GRAIN_PARAMS: AVFrameSideDataType = 23;
#[doc = " @defgroup lavu_frame AVFrame"]
#[doc = " @ingroup lavu_data"]
#[doc = ""]
#[doc = " @{"]
#[doc = " AVFrame is an abstraction for reference-counted raw multimedia data."]
pub type AVFrameSideDataType = ::std::os::raw::c_uint;
pub const AVActiveFormatDescription_AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AVActiveFormatDescription_AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AVActiveFormatDescription_AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AVActiveFormatDescription_AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AVActiveFormatDescription_AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = ::std::os::raw::c_uint;
#[doc = " Structure to hold side data for an AVFrame."]
#[doc = ""]
#[doc = " sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added"]
#[doc = " to the end with a minor bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: ::std::os::raw::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
impl Default for AVFrameSideData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Structure describing a single Region Of Interest."]
#[doc = ""]
#[doc = " When multiple regions are defined in a single side-data block, they"]
#[doc = " should be ordered from most to least important - some encoders are only"]
#[doc = " capable of supporting a limited number of distinct regions, so will have"]
#[doc = " to truncate the list."]
#[doc = ""]
#[doc = " When overlapping regions are defined, the first region containing a given"]
#[doc = " area of the frame applies."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVRegionOfInterest {
    #[doc = " Must be set to the size of this data structure (that is,"]
    #[doc = " sizeof(AVRegionOfInterest))."]
    pub self_size: u32,
    #[doc = " Distance in pixels from the top edge of the frame to the top and"]
    #[doc = " bottom edges and from the left edge of the frame to the left and"]
    #[doc = " right edges of the rectangle defining this region of interest."]
    #[doc = ""]
    #[doc = " The constraints on a region are encoder dependent, so the region"]
    #[doc = " actually affected may be slightly larger for alignment or other"]
    #[doc = " reasons."]
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    #[doc = " Quantisation offset."]
    #[doc = ""]
    #[doc = " Must be in the range -1 to +1.  A value of zero indicates no quality"]
    #[doc = " change.  A negative value asks for better quality (less quantisation),"]
    #[doc = " while a positive value asks for worse quality (greater quantisation)."]
    #[doc = ""]
    #[doc = " The range is calibrated so that the extreme values indicate the"]
    #[doc = " largest possible offset - if the rest of the frame is encoded with the"]
    #[doc = " worst possible quality, an offset of -1 indicates that this region"]
    #[doc = " should be encoded with the best possible quality anyway.  Intermediate"]
    #[doc = " values are then interpolated in some codec-dependent way."]
    #[doc = ""]
    #[doc = " For example, in 10-bit H.264 the quantisation parameter varies between"]
    #[doc = " -12 and 51.  A typical qoffset value of -1/10 therefore indicates that"]
    #[doc = " this region should be encoded with a QP around one-tenth of the full"]
    #[doc = " range better than the rest of the frame.  So, if most of the frame"]
    #[doc = " were to be encoded with a QP of around 30, this region would get a QP"]
    #[doc = " of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3)."]
    #[doc = " An extreme value of -1 would indicate that this region should be"]
    #[doc = " encoded with the best possible quality regardless of the treatment of"]
    #[doc = " the rest of the frame - that is, should be encoded at a QP of -12."]
    pub qoffset: AVRational,
}
#[doc = " This structure describes decoded (raw) audio or video data."]
#[doc = ""]
#[doc = " AVFrame must be allocated using av_frame_alloc(). Note that this only"]
#[doc = " allocates the AVFrame itself, the buffers for the data must be managed"]
#[doc = " through other means (see below)."]
#[doc = " AVFrame must be freed with av_frame_free()."]
#[doc = ""]
#[doc = " AVFrame is typically allocated once and then reused multiple times to hold"]
#[doc = " different data (e.g. a single AVFrame to hold frames received from a"]
#[doc = " decoder). In such a case, av_frame_unref() will free any references held by"]
#[doc = " the frame and reset it to its original clean state before it"]
#[doc = " is reused again."]
#[doc = ""]
#[doc = " The data described by an AVFrame is usually reference counted through the"]
#[doc = " AVBuffer API. The underlying buffer references are stored in AVFrame.buf /"]
#[doc = " AVFrame.extended_buf. An AVFrame is considered to be reference counted if at"]
#[doc = " least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,"]
#[doc = " every single data plane must be contained in one of the buffers in"]
#[doc = " AVFrame.buf or AVFrame.extended_buf."]
#[doc = " There may be a single buffer for all the data, or one separate buffer for"]
#[doc = " each plane, or anything in between."]
#[doc = ""]
#[doc = " sizeof(AVFrame) is not a part of the public ABI, so new fields may be added"]
#[doc = " to the end with a minor bump."]
#[doc = ""]
#[doc = " Fields can be accessed through AVOptions, the name string used, matches the"]
#[doc = " C structure field name for fields accessible through AVOptions. The AVClass"]
#[doc = " for AVFrame can be obtained from avcodec_get_frame_class()"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFrame {
    #[doc = " pointer to the picture/channel planes."]
    #[doc = " This might be different from the first allocated byte"]
    #[doc = ""]
    #[doc = " Some decoders access areas outside 0,0 - width,height, please"]
    #[doc = " see avcodec_align_dimensions2(). Some filters and swscale can read"]
    #[doc = " up to 16 bytes beyond the planes, if these filters are to be used,"]
    #[doc = " then 16 extra bytes must be allocated."]
    #[doc = ""]
    #[doc = " NOTE: Except for hwaccel formats, pointers not needed by the format"]
    #[doc = " MUST be set to NULL."]
    pub data: [*mut u8; 8usize],
    #[doc = " For video, size in bytes of each picture line."]
    #[doc = " For audio, size in bytes of each plane."]
    #[doc = ""]
    #[doc = " For audio, only linesize[0] may be set. For planar audio, each channel"]
    #[doc = " plane must be the same size."]
    #[doc = ""]
    #[doc = " For video the linesizes should be multiples of the CPUs alignment"]
    #[doc = " preference, this is 16 or 32 for modern desktop CPUs."]
    #[doc = " Some code requires such alignment other code can be slower without"]
    #[doc = " correct alignment, for yet other it makes no difference."]
    #[doc = ""]
    #[doc = " @note The linesize may be larger than the size of usable data -- there"]
    #[doc = " may be extra padding present for performance reasons."]
    pub linesize: [::std::os::raw::c_int; 8usize],
    #[doc = " pointers to the data planes/channels."]
    #[doc = ""]
    #[doc = " For video, this should simply point to data[]."]
    #[doc = ""]
    #[doc = " For planar audio, each channel has a separate data pointer, and"]
    #[doc = " linesize[0] contains the size of each channel buffer."]
    #[doc = " For packed audio, there is just one data pointer, and linesize[0]"]
    #[doc = " contains the total size of the buffer for all channels."]
    #[doc = ""]
    #[doc = " Note: Both data and extended_data should always be set in a valid frame,"]
    #[doc = " but for planar audio with more channels that can fit in data,"]
    #[doc = " extended_data must be used in order to access all channels."]
    pub extended_data: *mut *mut u8,
    #[doc = " @name Video dimensions"]
    #[doc = " Video frames only. The coded dimensions (in pixels) of the video frame,"]
    #[doc = " i.e. the size of the rectangle that contains some well-defined values."]
    #[doc = ""]
    #[doc = " @note The part of the frame intended for display/presentation is further"]
    #[doc = " restricted by the @ref cropping \"Cropping rectangle\"."]
    #[doc = " @{"]
    pub width: ::std::os::raw::c_int,
    #[doc = " @name Video dimensions"]
    #[doc = " Video frames only. The coded dimensions (in pixels) of the video frame,"]
    #[doc = " i.e. the size of the rectangle that contains some well-defined values."]
    #[doc = ""]
    #[doc = " @note The part of the frame intended for display/presentation is further"]
    #[doc = " restricted by the @ref cropping \"Cropping rectangle\"."]
    #[doc = " @{"]
    pub height: ::std::os::raw::c_int,
    #[doc = " number of audio samples (per channel) described by this frame"]
    pub nb_samples: ::std::os::raw::c_int,
    #[doc = " format of the frame, -1 if unknown or unset"]
    #[doc = " Values correspond to enum AVPixelFormat for video frames,"]
    #[doc = " enum AVSampleFormat for audio)"]
    pub format: ::std::os::raw::c_int,
    #[doc = " 1 -> keyframe, 0-> not"]
    pub key_frame: ::std::os::raw::c_int,
    #[doc = " Picture type of the frame."]
    pub pict_type: AVPictureType,
    #[doc = " Sample aspect ratio for the video frame, 0/1 if unknown/unspecified."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Presentation timestamp in time_base units (time when frame should be shown to user)."]
    pub pts: i64,
    #[doc = " PTS copied from the AVPacket that was decoded to produce this frame."]
    #[doc = " @deprecated use the pts field instead"]
    pub pkt_pts: i64,
    #[doc = " DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)"]
    #[doc = " This is also the Presentation time of this AVFrame calculated from"]
    #[doc = " only AVPacket.dts values without pts values."]
    pub pkt_dts: i64,
    #[doc = " picture number in bitstream order"]
    pub coded_picture_number: ::std::os::raw::c_int,
    #[doc = " picture number in display order"]
    pub display_picture_number: ::std::os::raw::c_int,
    #[doc = " quality (between 1 (good) and FF_LAMBDA_MAX (bad))"]
    pub quality: ::std::os::raw::c_int,
    #[doc = " for some private data of the user"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " @deprecated unused"]
    pub error: [u64; 8usize],
    #[doc = " When decoding, this signals how much the picture must be delayed."]
    #[doc = " extra_delay = repeat_pict / (2*fps)"]
    pub repeat_pict: ::std::os::raw::c_int,
    #[doc = " The content of the picture is interlaced."]
    pub interlaced_frame: ::std::os::raw::c_int,
    #[doc = " If the content is interlaced, is top field displayed first."]
    pub top_field_first: ::std::os::raw::c_int,
    #[doc = " Tell user application that palette has changed from previous frame."]
    pub palette_has_changed: ::std::os::raw::c_int,
    #[doc = " reordered opaque 64 bits (generally an integer or a double precision float"]
    #[doc = " PTS but can be anything)."]
    #[doc = " The user sets AVCodecContext.reordered_opaque to represent the input at"]
    #[doc = " that time,"]
    #[doc = " the decoder reorders values as needed and sets AVFrame.reordered_opaque"]
    #[doc = " to exactly one of the values provided by the user through AVCodecContext.reordered_opaque"]
    pub reordered_opaque: i64,
    #[doc = " Sample rate of the audio data."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Channel layout of the audio data."]
    pub channel_layout: u64,
    #[doc = " AVBuffer references backing the data for this frame. If all elements of"]
    #[doc = " this array are NULL, then this frame is not reference counted. This array"]
    #[doc = " must be filled contiguously -- if buf[i] is non-NULL then buf[j] must"]
    #[doc = " also be non-NULL for all j < i."]
    #[doc = ""]
    #[doc = " There may be at most one AVBuffer per data plane, so for video this array"]
    #[doc = " always contains all the references. For planar audio with more than"]
    #[doc = " AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in"]
    #[doc = " this array. Then the extra AVBufferRef pointers are stored in the"]
    #[doc = " extended_buf array."]
    pub buf: [*mut AVBufferRef; 8usize],
    #[doc = " For planar audio which requires more than AV_NUM_DATA_POINTERS"]
    #[doc = " AVBufferRef pointers, this array will hold all the references which"]
    #[doc = " cannot fit into AVFrame.buf."]
    #[doc = ""]
    #[doc = " Note that this is different from AVFrame.extended_data, which always"]
    #[doc = " contains all the pointers. This array only contains the extra pointers,"]
    #[doc = " which cannot fit into AVFrame.buf."]
    #[doc = ""]
    #[doc = " This array is always allocated using av_malloc() by whoever constructs"]
    #[doc = " the frame. It is freed in av_frame_unref()."]
    pub extended_buf: *mut *mut AVBufferRef,
    #[doc = " Number of elements in extended_buf."]
    pub nb_extended_buf: ::std::os::raw::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    #[doc = " Frame flags, a combination of @ref lavu_frame_flags"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " MPEG vs JPEG YUV range."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type."]
    #[doc = " - encoding: Set by user"]
    #[doc = " - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " frame timestamp estimated using various heuristics, in stream time base"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by libavcodec, read by user."]
    pub best_effort_timestamp: i64,
    #[doc = " reordered pos from the last AVPacket that has been input into the decoder"]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Read by user."]
    pub pkt_pos: i64,
    #[doc = " duration of the corresponding packet, expressed in"]
    #[doc = " AVStream->time_base units, 0 if unknown."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Read by user."]
    pub pkt_duration: i64,
    #[doc = " metadata."]
    #[doc = " - encoding: Set by user."]
    #[doc = " - decoding: Set by libavcodec."]
    pub metadata: *mut AVDictionary,
    #[doc = " decode error flags of the frame, set to a combination of"]
    #[doc = " FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there"]
    #[doc = " were errors during the decoding."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by libavcodec, read by user."]
    pub decode_error_flags: ::std::os::raw::c_int,
    #[doc = " number of audio channels, only used for audio."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: Read by user."]
    pub channels: ::std::os::raw::c_int,
    #[doc = " size of the corresponding packet containing the compressed"]
    #[doc = " frame."]
    #[doc = " It is set to a negative value if unknown."]
    #[doc = " - encoding: unused"]
    #[doc = " - decoding: set by libavcodec, read by user."]
    pub pkt_size: ::std::os::raw::c_int,
    #[doc = " QP table"]
    pub qscale_table: *mut i8,
    #[doc = " QP store stride"]
    pub qstride: ::std::os::raw::c_int,
    pub qscale_type: ::std::os::raw::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    #[doc = " For hwaccel-format frames, this should be a reference to the"]
    #[doc = " AVHWFramesContext describing the frame."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the"]
    #[doc = " contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when"]
    #[doc = " the frame is unreferenced. av_frame_copy_props() calls create a new"]
    #[doc = " reference with av_buffer_ref() for the target frame's opaque_ref field."]
    #[doc = ""]
    #[doc = " This is unrelated to the opaque field, although it serves a similar"]
    #[doc = " purpose."]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " @anchor cropping"]
    #[doc = " @name Cropping"]
    #[doc = " Video frames only. The number of pixels to discard from the the"]
    #[doc = " top/bottom/left/right border of the frame to obtain the sub-rectangle of"]
    #[doc = " the frame intended for presentation."]
    #[doc = " @{"]
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    #[doc = " AVBufferRef for internal use by a single libav* library."]
    #[doc = " Must not be used to transfer data between libraries."]
    #[doc = " Has to be NULL when ownership of the frame leaves the respective library."]
    #[doc = ""]
    #[doc = " Code outside the FFmpeg libs should never check or change the contents of the buffer ref."]
    #[doc = ""]
    #[doc = " FFmpeg calls av_buffer_unref() on it when the frame is unreferenced."]
    #[doc = " av_frame_copy_props() calls create a new reference with av_buffer_ref()"]
    #[doc = " for the target frame's private_ref field."]
    pub private_ref: *mut AVBufferRef,
}
impl Default for AVFrame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Accessors for some AVFrame fields. These used to be provided for ABI"]
    #[doc = " compatibility, and do not need to be used anymore."]
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_frame_get_qp_table(
        f: *mut AVFrame,
        stride: *mut ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(
        f: *mut AVFrame,
        buf: *mut AVBufferRef,
        stride: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    #[doc = " Get the name of a colorspace."]
    #[doc = " @return a static string identifying the colorspace; can be NULL."]
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocate an AVFrame and set its fields to default values.  The resulting"]
    #[doc = " struct must be freed using av_frame_free()."]
    #[doc = ""]
    #[doc = " @return An AVFrame filled with default values or NULL on failure."]
    #[doc = ""]
    #[doc = " @note this only allocates the AVFrame itself, not the data buffers. Those"]
    #[doc = " must be allocated through other means, e.g. with av_frame_get_buffer() or"]
    #[doc = " manually."]
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    #[doc = " Free the frame and any dynamically allocated objects in it,"]
    #[doc = " e.g. extended_data. If the frame is reference counted, it will be"]
    #[doc = " unreferenced first."]
    #[doc = ""]
    #[doc = " @param frame frame to be freed. The pointer will be set to NULL."]
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    #[doc = " Set up a new reference to the data described by the source frame."]
    #[doc = ""]
    #[doc = " Copy frame properties from src to dst and create a new reference for each"]
    #[doc = " AVBufferRef from src."]
    #[doc = ""]
    #[doc = " If src is not reference counted, new buffers are allocated and the data is"]
    #[doc = " copied."]
    #[doc = ""]
    #[doc = " @warning: dst MUST have been either unreferenced with av_frame_unref(dst),"]
    #[doc = "           or newly allocated with av_frame_alloc() before calling this"]
    #[doc = "           function, or undefined behavior will occur."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error"]
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new frame that references the same data as src."]
    #[doc = ""]
    #[doc = " This is a shortcut for av_frame_alloc()+av_frame_ref()."]
    #[doc = ""]
    #[doc = " @return newly created AVFrame on success, NULL on error."]
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    #[doc = " Unreference all the buffers referenced by frame and reset the frame fields."]
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    #[doc = " Move everything contained in src to dst and reset src."]
    #[doc = ""]
    #[doc = " @warning: dst is not unreferenced, but directly overwritten without reading"]
    #[doc = "           or deallocating its contents. Call av_frame_unref(dst) manually"]
    #[doc = "           before calling this function to ensure that no memory is leaked."]
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    #[doc = " Allocate new buffer(s) for audio or video data."]
    #[doc = ""]
    #[doc = " The following fields must be set on frame before calling this function:"]
    #[doc = " - format (pixel format for video, sample format for audio)"]
    #[doc = " - width and height for video"]
    #[doc = " - nb_samples and channel_layout for audio"]
    #[doc = ""]
    #[doc = " This function will fill AVFrame.data and AVFrame.buf arrays and, if"]
    #[doc = " necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf."]
    #[doc = " For planar formats, one buffer will be allocated for each plane."]
    #[doc = ""]
    #[doc = " @warning: if frame already has been allocated, calling this function will"]
    #[doc = "           leak memory. In addition, undefined behavior can occur in certain"]
    #[doc = "           cases."]
    #[doc = ""]
    #[doc = " @param frame frame in which to store the new buffers."]
    #[doc = " @param align Required buffer size alignment. If equal to 0, alignment will be"]
    #[doc = "              chosen automatically for the current CPU. It is highly"]
    #[doc = "              recommended to pass 0 here unless you know what you are doing."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error."]
    pub fn av_frame_get_buffer(
        frame: *mut AVFrame,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the frame data is writable."]
    #[doc = ""]
    #[doc = " @return A positive value if the frame data is writable (which is true if and"]
    #[doc = " only if each of the underlying buffers has only one reference, namely the one"]
    #[doc = " stored in this frame). Return 0 otherwise."]
    #[doc = ""]
    #[doc = " If 1 is returned the answer is valid until av_buffer_ref() is called on any"]
    #[doc = " of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly)."]
    #[doc = ""]
    #[doc = " @see av_frame_make_writable(), av_buffer_is_writable()"]
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure that the frame data is writable, avoiding data copy if possible."]
    #[doc = ""]
    #[doc = " Do nothing if the frame is writable, allocate new buffers and copy the data"]
    #[doc = " if it is not."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on error."]
    #[doc = ""]
    #[doc = " @see av_frame_is_writable(), av_buffer_is_writable(),"]
    #[doc = " av_buffer_make_writable()"]
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the frame data from src to dst."]
    #[doc = ""]
    #[doc = " This function does not allocate anything, dst must be already initialized and"]
    #[doc = " allocated with the same parameters as src."]
    #[doc = ""]
    #[doc = " This function only copies the frame data (i.e. the contents of the data /"]
    #[doc = " extended data arrays), not any other properties."]
    #[doc = ""]
    #[doc = " @return >= 0 on success, a negative AVERROR on error."]
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy only \"metadata\" fields from src to dst."]
    #[doc = ""]
    #[doc = " Metadata for the purpose of this function are those fields that do not affect"]
    #[doc = " the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample"]
    #[doc = " aspect ratio (for video), but not width/height or channel layout."]
    #[doc = " Side data is also copied."]
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the buffer reference a given data plane is stored in."]
    #[doc = ""]
    #[doc = " @param plane index of the data plane of interest in frame->extended_data."]
    #[doc = ""]
    #[doc = " @return the buffer reference that contains the plane or NULL if the input"]
    #[doc = " frame is not valid."]
    pub fn av_frame_get_plane_buffer(
        frame: *mut AVFrame,
        plane: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Add a new side data to a frame."]
    #[doc = ""]
    #[doc = " @param frame a frame to which the side data should be added"]
    #[doc = " @param type type of the added side data"]
    #[doc = " @param size size of the side data"]
    #[doc = ""]
    #[doc = " @return newly added side data on success, NULL on error"]
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: ::std::os::raw::c_int,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Add a new side data to a frame from an existing AVBufferRef"]
    #[doc = ""]
    #[doc = " @param frame a frame to which the side data should be added"]
    #[doc = " @param type  the type of the added side data"]
    #[doc = " @param buf   an AVBufferRef to add as side data. The ownership of"]
    #[doc = "              the reference is transferred to the frame."]
    #[doc = ""]
    #[doc = " @return newly added side data on success, NULL on error. On failure"]
    #[doc = "         the frame is unchanged and the AVBufferRef remains owned by"]
    #[doc = "         the caller."]
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " @return a pointer to the side data of a given type on success, NULL if there"]
    #[doc = " is no side data with such type in this frame."]
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Remove and free all side data instances of the given type."]
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
#[doc = " Apply the maximum possible cropping, even if it requires setting the"]
#[doc = " AVFrame.data[] entries to unaligned pointers. Passing unaligned data"]
#[doc = " to FFmpeg API is generally not allowed, and causes undefined behavior"]
#[doc = " (such as crashes). You can pass unaligned data only to FFmpeg APIs that"]
#[doc = " are explicitly documented to accept it. Use this flag only if you"]
#[doc = " absolutely know what you are doing."]
pub const AV_FRAME_CROP_UNALIGNED: ::std::os::raw::c_uint = 1;
#[doc = " Flags for frame cropping."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Crop the given video AVFrame according to its crop_left/crop_top/crop_right/"]
    #[doc = " crop_bottom fields. If cropping is successful, the function will adjust the"]
    #[doc = " data pointers and the width/height fields, and set the crop fields to 0."]
    #[doc = ""]
    #[doc = " In all cases, the cropping boundaries will be rounded to the inherent"]
    #[doc = " alignment of the pixel format. In some cases, such as for opaque hwaccel"]
    #[doc = " formats, the left/top cropping is ignored. The crop fields are set to 0 even"]
    #[doc = " if the cropping was rounded or ignored."]
    #[doc = ""]
    #[doc = " @param frame the frame which should be cropped"]
    #[doc = " @param flags Some combination of AV_FRAME_CROP_* flags, or 0."]
    #[doc = ""]
    #[doc = " @return >= 0 on success, a negative AVERROR on error. If the cropping fields"]
    #[doc = " were invalid, AVERROR(ERANGE) is returned, and nothing is changed."]
    pub fn av_frame_apply_cropping(
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a string identifying the side data type"]
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the LIBAVFILTER_VERSION_INT constant."]
    pub fn avfilter_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libavfilter build-time configuration."]
    pub fn avfilter_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavfilter license."]
    pub fn avfilter_license() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterPad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterFormats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterChannelLayouts {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the number of elements in a NULL-terminated array of AVFilterPads (e.g."]
    #[doc = " AVFilter.inputs/outputs)."]
    pub fn avfilter_pad_count(pads: *const AVFilterPad) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of an AVFilterPad."]
    #[doc = ""]
    #[doc = " @param pads an array of AVFilterPads"]
    #[doc = " @param pad_idx index of the pad in the array; it is the caller's"]
    #[doc = "                responsibility to ensure the index is valid"]
    #[doc = ""]
    #[doc = " @return name of the pad_idx'th pad in pads"]
    pub fn avfilter_pad_get_name(
        pads: *const AVFilterPad,
        pad_idx: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the type of an AVFilterPad."]
    #[doc = ""]
    #[doc = " @param pads an array of AVFilterPads"]
    #[doc = " @param pad_idx index of the pad in the array; it is the caller's"]
    #[doc = "                responsibility to ensure the index is valid"]
    #[doc = ""]
    #[doc = " @return type of the pad_idx'th pad in pads"]
    pub fn avfilter_pad_get_type(
        pads: *const AVFilterPad,
        pad_idx: ::std::os::raw::c_int,
    ) -> AVMediaType;
}
#[doc = " Filter definition. This defines the pads a filter contains, and all the"]
#[doc = " callback functions used to interact with the filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFilter {
    #[doc = " Filter name. Must be non-NULL and unique among filters."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " A description of the filter. May be NULL."]
    #[doc = ""]
    #[doc = " You should use the NULL_IF_CONFIG_SMALL() macro to define it."]
    pub description: *const ::std::os::raw::c_char,
    #[doc = " List of inputs, terminated by a zeroed element."]
    #[doc = ""]
    #[doc = " NULL if there are no (static) inputs. Instances of filters with"]
    #[doc = " AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in"]
    #[doc = " this list."]
    pub inputs: *const AVFilterPad,
    #[doc = " List of outputs, terminated by a zeroed element."]
    #[doc = ""]
    #[doc = " NULL if there are no (static) outputs. Instances of filters with"]
    #[doc = " AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in"]
    #[doc = " this list."]
    pub outputs: *const AVFilterPad,
    #[doc = " A class for the private data, used to declare filter private AVOptions."]
    #[doc = " This field is NULL for filters that do not declare any options."]
    #[doc = ""]
    #[doc = " If this field is non-NULL, the first member of the filter private data"]
    #[doc = " must be a pointer to AVClass, which will be set by libavfilter generic"]
    #[doc = " code to this class."]
    pub priv_class: *const AVClass,
    #[doc = " A combination of AVFILTER_FLAG_*"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " Filter pre-initialization function"]
    #[doc = ""]
    #[doc = " This callback will be called immediately after the filter context is"]
    #[doc = " allocated, to allow allocating and initing sub-objects."]
    #[doc = ""]
    #[doc = " If this callback is not NULL, the uninit callback will be called on"]
    #[doc = " allocation failure."]
    #[doc = ""]
    #[doc = " @return 0 on success,"]
    #[doc = "         AVERROR code on failure (but the code will be"]
    #[doc = "           dropped and treated as ENOMEM by the calling code)"]
    pub preinit: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter initialization function."]
    #[doc = ""]
    #[doc = " This callback will be called only once during the filter lifetime, after"]
    #[doc = " all the options have been set, but before links between filters are"]
    #[doc = " established and format negotiation is done."]
    #[doc = ""]
    #[doc = " Basic filter initialization should be done here. Filters with dynamic"]
    #[doc = " inputs and/or outputs should create those inputs/outputs here based on"]
    #[doc = " provided options. No more changes to this filter's inputs/outputs can be"]
    #[doc = " done after this callback."]
    #[doc = ""]
    #[doc = " This callback must not assume that the filter links exist or frame"]
    #[doc = " parameters are known."]
    #[doc = ""]
    #[doc = " @ref AVFilter.uninit \"uninit\" is guaranteed to be called even if"]
    #[doc = " initialization fails, so this callback does not have to clean up on"]
    #[doc = " failure."]
    #[doc = ""]
    #[doc = " @return 0 on success, a negative AVERROR on failure"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
    #[doc = " Should be set instead of @ref AVFilter.init \"init\" by the filters that"]
    #[doc = " want to pass a dictionary of AVOptions to nested contexts that are"]
    #[doc = " allocated during init."]
    #[doc = ""]
    #[doc = " On return, the options dict should be freed and replaced with one that"]
    #[doc = " contains all the options which could not be processed by this filter (or"]
    #[doc = " with NULL if all the options were processed)."]
    #[doc = ""]
    #[doc = " Otherwise the semantics is the same as for @ref AVFilter.init \"init\"."]
    pub init_dict: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut AVFilterContext,
            options: *mut *mut AVDictionary,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter uninitialization function."]
    #[doc = ""]
    #[doc = " Called only once right before the filter is freed. Should deallocate any"]
    #[doc = " memory held by the filter, release any buffer references, etc. It does"]
    #[doc = " not need to deallocate the AVFilterContext.priv memory itself."]
    #[doc = ""]
    #[doc = " This callback may be called even if @ref AVFilter.init \"init\" was not"]
    #[doc = " called or failed, so it must be prepared to handle such a situation."]
    pub uninit: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext)>,
    #[doc = " Query formats supported by the filter on its inputs and outputs."]
    #[doc = ""]
    #[doc = " This callback is called after the filter is initialized (so the inputs"]
    #[doc = " and outputs are fixed), shortly before the format negotiation. This"]
    #[doc = " callback may be called more than once."]
    #[doc = ""]
    #[doc = " This callback must set AVFilterLink.outcfg.formats on every input link and"]
    #[doc = " AVFilterLink.incfg.formats on every output link to a list of pixel/sample"]
    #[doc = " formats that the filter supports on that link. For audio links, this"]
    #[doc = " filter must also set @ref AVFilterLink.incfg.samplerates \"in_samplerates\" /"]
    #[doc = " @ref AVFilterLink.outcfg.samplerates \"out_samplerates\" and"]
    #[doc = " @ref AVFilterLink.incfg.channel_layouts \"in_channel_layouts\" /"]
    #[doc = " @ref AVFilterLink.outcfg.channel_layouts \"out_channel_layouts\" analogously."]
    #[doc = ""]
    #[doc = " This callback may be NULL for filters with one input, in which case"]
    #[doc = " libavfilter assumes that it supports all input formats and preserves"]
    #[doc = " them on output."]
    #[doc = ""]
    #[doc = " @return zero on success, a negative value corresponding to an"]
    #[doc = " AVERROR code otherwise"]
    pub query_formats: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
    #[doc = "< size of private data to allocate for the filter"]
    pub priv_size: ::std::os::raw::c_int,
    #[doc = "< Additional flags for avfilter internal use only."]
    pub flags_internal: ::std::os::raw::c_int,
    #[doc = " Used by the filter registration system. Must not be touched by any other"]
    #[doc = " code."]
    pub next: *mut AVFilter,
    #[doc = " Make the filter instance process a command."]
    #[doc = ""]
    #[doc = " @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only"]
    #[doc = " @param arg    the argument for the command"]
    #[doc = " @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported."]
    #[doc = " @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be"]
    #[doc = "               time consuming then a filter should treat it like an unsupported command"]
    #[doc = ""]
    #[doc = " @returns >=0 on success otherwise an error code."]
    #[doc = "          AVERROR(ENOSYS) on unsupported commands"]
    pub process_command: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFilterContext,
            cmd: *const ::std::os::raw::c_char,
            arg: *const ::std::os::raw::c_char,
            res: *mut ::std::os::raw::c_char,
            res_len: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter initialization function, alternative to the init()"]
    #[doc = " callback. Args contains the user-supplied parameters, opaque is"]
    #[doc = " used for providing binary data."]
    pub init_opaque: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut AVFilterContext,
            opaque: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Filter activation function."]
    #[doc = ""]
    #[doc = " Called when any processing is needed from the filter, instead of any"]
    #[doc = " filter_frame and request_frame on pads."]
    #[doc = ""]
    #[doc = " The function must examine inlinks and outlinks and perform a single"]
    #[doc = " step of processing. If there is nothing to do, the function must do"]
    #[doc = " nothing and not return an error. If more steps are or may be"]
    #[doc = " possible, it must use ff_filter_set_ready() to schedule another"]
    #[doc = " activation."]
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext) -> ::std::os::raw::c_int,
    >,
}
impl Default for AVFilter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterInternal {
    _unused: [u8; 0],
}
#[doc = " An instance of a filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFilterContext {
    #[doc = "< needed for av_log() and filters common options"]
    pub av_class: *const AVClass,
    #[doc = "< the AVFilter of which this is an instance"]
    pub filter: *const AVFilter,
    #[doc = "< name of this filter instance"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< array of input pads"]
    pub input_pads: *mut AVFilterPad,
    #[doc = "< array of pointers to input links"]
    pub inputs: *mut *mut AVFilterLink,
    #[doc = "< number of input pads"]
    pub nb_inputs: ::std::os::raw::c_uint,
    #[doc = "< array of output pads"]
    pub output_pads: *mut AVFilterPad,
    #[doc = "< array of pointers to output links"]
    pub outputs: *mut *mut AVFilterLink,
    #[doc = "< number of output pads"]
    pub nb_outputs: ::std::os::raw::c_uint,
    #[doc = "< private data for use by the filter"]
    pub priv_: *mut ::std::os::raw::c_void,
    #[doc = "< filtergraph this filter belongs to"]
    pub graph: *mut AVFilterGraph,
    #[doc = " Type of multithreading being allowed/used. A combination of"]
    #[doc = " AVFILTER_THREAD_* flags."]
    #[doc = ""]
    #[doc = " May be set by the caller before initializing the filter to forbid some"]
    #[doc = " or all kinds of multithreading for this filter. The default is allowing"]
    #[doc = " everything."]
    #[doc = ""]
    #[doc = " When the filter is initialized, this field is combined using bit AND with"]
    #[doc = " AVFilterGraph.thread_type to get the final mask used for determining"]
    #[doc = " allowed threading types. I.e. a threading type needs to be set in both"]
    #[doc = " to be allowed."]
    #[doc = ""]
    #[doc = " After the filter is initialized, libavfilter sets this field to the"]
    #[doc = " threading type that is actually used (0 for no multithreading)."]
    pub thread_type: ::std::os::raw::c_int,
    #[doc = " An opaque struct for libavfilter internal use."]
    pub internal: *mut AVFilterInternal,
    pub command_queue: *mut AVFilterCommand,
    #[doc = "< enable expression string"]
    pub enable_str: *mut ::std::os::raw::c_char,
    #[doc = "< parsed expression (AVExpr*)"]
    pub enable: *mut ::std::os::raw::c_void,
    #[doc = "< variable values for the enable expression"]
    pub var_values: *mut f64,
    #[doc = "< the enabled state from the last expression evaluation"]
    pub is_disabled: ::std::os::raw::c_int,
    #[doc = " For filters which will create hardware frames, sets the device the"]
    #[doc = " filter should create them in.  All other filters will ignore this field:"]
    #[doc = " in particular, a filter which consumes or processes hardware frames will"]
    #[doc = " instead use the hw_frames_ctx field in AVFilterLink to carry the"]
    #[doc = " hardware context information."]
    pub hw_device_ctx: *mut AVBufferRef,
    #[doc = " Max number of threads allowed in this filter instance."]
    #[doc = " If <= 0, its value is ignored."]
    #[doc = " Overrides global number of threads set per filter graph."]
    pub nb_threads: ::std::os::raw::c_int,
    #[doc = " Ready status of the filter."]
    #[doc = " A non-0 value means that the filter needs activating;"]
    #[doc = " a higher value suggests a more urgent activation."]
    pub ready: ::std::os::raw::c_uint,
    #[doc = " Sets the number of extra hardware frames which the filter will"]
    #[doc = " allocate on its output links for use in following filters or by"]
    #[doc = " the caller."]
    #[doc = ""]
    #[doc = " Some hardware filters require all frames that they will use for"]
    #[doc = " output to be defined in advance before filtering starts.  For such"]
    #[doc = " filters, any hardware frame pools used for output must therefore be"]
    #[doc = " of fixed size.  The extra frames set here are on top of any number"]
    #[doc = " that the filter needs internally in order to operate normally."]
    #[doc = ""]
    #[doc = " This field must be set before the graph containing this filter is"]
    #[doc = " configured."]
    pub extra_hw_frames: ::std::os::raw::c_int,
}
impl Default for AVFilterContext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Lists of formats / etc. supported by an end of a link."]
#[doc = ""]
#[doc = " This structure is directly part of AVFilterLink, in two copies:"]
#[doc = " one for the source filter, one for the destination filter."]
#[doc = ""]
#[doc = " These lists are used for negotiating the format to actually be used,"]
#[doc = " which will be loaded into the format and channel_layout members of"]
#[doc = " AVFilterLink, when chosen."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFilterFormatsConfig {
    #[doc = " List of supported formats (pixel or sample)."]
    pub formats: *mut AVFilterFormats,
    #[doc = " Lists of supported sample rates, only for audio."]
    pub samplerates: *mut AVFilterFormats,
    #[doc = " Lists of supported channel layouts, only for audio."]
    pub channel_layouts: *mut AVFilterChannelLayouts,
}
impl Default for AVFilterFormatsConfig {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " A link between two filters. This contains pointers to the source and"]
#[doc = " destination filters between which this link exists, and the indexes of"]
#[doc = " the pads involved. In addition, this link also contains the parameters"]
#[doc = " which have been negotiated and agreed upon between the filter, such as"]
#[doc = " image dimensions, format, etc."]
#[doc = ""]
#[doc = " Applications must not normally access the link structure directly."]
#[doc = " Use the buffersrc and buffersink API instead."]
#[doc = " In the future, access to the header may be reserved for filters"]
#[doc = " implementation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilterLink {
    #[doc = "< source filter"]
    pub src: *mut AVFilterContext,
    #[doc = "< output pad on the source filter"]
    pub srcpad: *mut AVFilterPad,
    #[doc = "< dest filter"]
    pub dst: *mut AVFilterContext,
    #[doc = "< input pad on the dest filter"]
    pub dstpad: *mut AVFilterPad,
    #[doc = "< filter media type"]
    pub type_: AVMediaType,
    #[doc = "< agreed upon image width"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< agreed upon image height"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< agreed upon sample aspect ratio"]
    pub sample_aspect_ratio: AVRational,
    #[doc = "< channel layout of current buffer (see libavutil/channel_layout.h)"]
    pub channel_layout: u64,
    #[doc = "< samples per second"]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = "< agreed upon media format"]
    pub format: ::std::os::raw::c_int,
    #[doc = " Define the time base used by the PTS of the frames/samples"]
    #[doc = " which will pass through this link."]
    #[doc = " During the configuration stage, each filter is supposed to"]
    #[doc = " change only the output timebase, while the timebase of the"]
    #[doc = " input link is assumed to be an unchangeable property."]
    pub time_base: AVRational,
    #[doc = " Lists of supported formats / etc. supported by the input filter."]
    pub incfg: AVFilterFormatsConfig,
    #[doc = " Lists of supported formats / etc. supported by the output filter."]
    pub outcfg: AVFilterFormatsConfig,
    pub init_state: AVFilterLink__bindgen_ty_1,
    #[doc = " Graph the filter belongs to."]
    pub graph: *mut AVFilterGraph,
    #[doc = " Current timestamp of the link, as defined by the most recent"]
    #[doc = " frame(s), in link time_base units."]
    pub current_pts: i64,
    #[doc = " Current timestamp of the link, as defined by the most recent"]
    #[doc = " frame(s), in AV_TIME_BASE units."]
    pub current_pts_us: i64,
    #[doc = " Index in the age array."]
    pub age_index: ::std::os::raw::c_int,
    #[doc = " Frame rate of the stream on the link, or 1/0 if unknown or variable;"]
    #[doc = " if left to 0/0, will be automatically copied from the first input"]
    #[doc = " of the source filter if it exists."]
    #[doc = ""]
    #[doc = " Sources should set it to the best estimation of the real frame rate."]
    #[doc = " If the source frame rate is unknown or variable, set this to 1/0."]
    #[doc = " Filters should update it if necessary depending on their function."]
    #[doc = " Sinks can use it to set a default output frame rate."]
    #[doc = " It is similar to the r_frame_rate field in AVStream."]
    pub frame_rate: AVRational,
    #[doc = " Buffer partially filled with samples to achieve a fixed/minimum size."]
    pub partial_buf: *mut AVFrame,
    #[doc = " Size of the partial buffer to allocate."]
    #[doc = " Must be between min_samples and max_samples."]
    pub partial_buf_size: ::std::os::raw::c_int,
    #[doc = " Minimum number of samples to filter at once. If filter_frame() is"]
    #[doc = " called with fewer samples, it will accumulate them in partial_buf."]
    #[doc = " This field and the related ones must not be changed after filtering"]
    #[doc = " has started."]
    #[doc = " If 0, all related fields are ignored."]
    pub min_samples: ::std::os::raw::c_int,
    #[doc = " Maximum number of samples to filter at once. If filter_frame() is"]
    #[doc = " called with more samples, it will split them."]
    pub max_samples: ::std::os::raw::c_int,
    #[doc = " Number of channels."]
    pub channels: ::std::os::raw::c_int,
    #[doc = " Number of past frames sent through the link."]
    pub frame_count_in: i64,
    #[doc = " Number of past frames sent through the link."]
    pub frame_count_out: i64,
    #[doc = " A pointer to a FFFramePool struct."]
    pub frame_pool: *mut ::std::os::raw::c_void,
    #[doc = " True if a frame is currently wanted on the output of this filter."]
    #[doc = " Set when ff_request_frame() is called by the output,"]
    #[doc = " cleared when a frame is filtered."]
    pub frame_wanted_out: ::std::os::raw::c_int,
    #[doc = " For hwaccel pixel formats, this should be a reference to the"]
    #[doc = " AVHWFramesContext describing the frames."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Internal structure members."]
    #[doc = " The fields below this limit are internal for libavfilter's use"]
    #[doc = " and must in no way be accessed by applications."]
    pub reserved: [::std::os::raw::c_char; 61440usize],
}
#[doc = "< not started"]
pub const AVFilterLink_AVLINK_UNINIT: ::std::os::raw::c_uint = 0;
#[doc = "< started, but incomplete"]
pub const AVFilterLink_AVLINK_STARTINIT: ::std::os::raw::c_uint = 1;
#[doc = "< complete"]
pub const AVFilterLink_AVLINK_INIT: ::std::os::raw::c_uint = 2;
#[doc = " stage of the initialization of the link properties (dimensions, etc)"]
pub type AVFilterLink__bindgen_ty_1 = ::std::os::raw::c_uint;
impl Default for AVFilterLink {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Link two filters together."]
    #[doc = ""]
    #[doc = " @param src    the source filter"]
    #[doc = " @param srcpad index of the output pad on the source filter"]
    #[doc = " @param dst    the destination filter"]
    #[doc = " @param dstpad index of the input pad on the destination filter"]
    #[doc = " @return       zero on success"]
    pub fn avfilter_link(
        src: *mut AVFilterContext,
        srcpad: ::std::os::raw::c_uint,
        dst: *mut AVFilterContext,
        dstpad: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the link in *link, and set its pointer to NULL."]
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
}
extern "C" {
    #[doc = " Get the number of channels of a link."]
    #[doc = " @deprecated Use av_buffersink_get_channels()"]
    pub fn avfilter_link_get_channels(link: *mut AVFilterLink) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the closed field of a link."]
    #[doc = " @deprecated applications are not supposed to mess with links, they should"]
    #[doc = " close the sinks."]
    pub fn avfilter_link_set_closed(link: *mut AVFilterLink, closed: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Negotiate the media format, dimensions, etc of all inputs to a filter."]
    #[doc = ""]
    #[doc = " @param filter the filter to negotiate the properties for its inputs"]
    #[doc = " @return       zero on successful negotiation"]
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Make the filter instance process a command."]
    #[doc = " It is recommended to use avfilter_graph_send_command()."]
    pub fn avfilter_process_command(
        filter: *mut AVFilterContext,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_char,
        res_len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over all registered filters."]
    #[doc = ""]
    #[doc = " @param opaque a pointer where libavfilter will store the iteration state. Must"]
    #[doc = "               point to NULL to start the iteration."]
    #[doc = ""]
    #[doc = " @return the next registered filter or NULL when the iteration is"]
    #[doc = "         finished"]
    pub fn av_filter_iterate(opaque: *mut *mut ::std::os::raw::c_void) -> *const AVFilter;
}
extern "C" {
    #[doc = " Initialize the filter system. Register all builtin filters."]
    pub fn avfilter_register_all();
}
extern "C" {
    #[doc = " Register a filter. This is only needed if you plan to use"]
    #[doc = " avfilter_get_by_name later to lookup the AVFilter structure by name. A"]
    #[doc = " filter can still by instantiated with avfilter_graph_alloc_filter even if it"]
    #[doc = " is not registered."]
    #[doc = ""]
    #[doc = " @param filter the filter to register"]
    #[doc = " @return 0 if the registration was successful, a negative value"]
    #[doc = " otherwise"]
    pub fn avfilter_register(filter: *mut AVFilter) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over all registered filters."]
    #[doc = " @return If prev is non-NULL, next registered filter after prev or NULL if"]
    #[doc = " prev is the last filter. If prev is NULL, return the first registered filter."]
    pub fn avfilter_next(prev: *const AVFilter) -> *const AVFilter;
}
extern "C" {
    #[doc = " Get a filter definition matching the given name."]
    #[doc = ""]
    #[doc = " @param name the filter name to find"]
    #[doc = " @return     the filter definition, if any matching one is registered."]
    #[doc = "             NULL if none found."]
    pub fn avfilter_get_by_name(name: *const ::std::os::raw::c_char) -> *const AVFilter;
}
extern "C" {
    #[doc = " Initialize a filter with the supplied parameters."]
    #[doc = ""]
    #[doc = " @param ctx  uninitialized filter context to initialize"]
    #[doc = " @param args Options to initialize the filter with. This must be a"]
    #[doc = "             ':'-separated list of options in the 'key=value' form."]
    #[doc = "             May be NULL if the options have been set directly using the"]
    #[doc = "             AVOptions API or there are no options that need to be set."]
    #[doc = " @return 0 on success, a negative AVERROR on failure"]
    pub fn avfilter_init_str(
        ctx: *mut AVFilterContext,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a filter with the supplied dictionary of options."]
    #[doc = ""]
    #[doc = " @param ctx     uninitialized filter context to initialize"]
    #[doc = " @param options An AVDictionary filled with options for this filter. On"]
    #[doc = "                return this parameter will be destroyed and replaced with"]
    #[doc = "                a dict containing options that were not found. This dictionary"]
    #[doc = "                must be freed by the caller."]
    #[doc = "                May be NULL, then this function is equivalent to"]
    #[doc = "                avfilter_init_str() with the second parameter set to NULL."]
    #[doc = " @return 0 on success, a negative AVERROR on failure"]
    #[doc = ""]
    #[doc = " @note This function and avfilter_init_str() do essentially the same thing,"]
    #[doc = " the difference is in manner in which the options are passed. It is up to the"]
    #[doc = " calling code to choose whichever is more preferable. The two functions also"]
    #[doc = " behave differently when some of the provided options are not declared as"]
    #[doc = " supported by the filter. In such a case, avfilter_init_str() will fail, but"]
    #[doc = " this function will leave those extra options in the options AVDictionary and"]
    #[doc = " continue as usual."]
    pub fn avfilter_init_dict(
        ctx: *mut AVFilterContext,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a filter context. This will also remove the filter from its"]
    #[doc = " filtergraph's list of filters."]
    #[doc = ""]
    #[doc = " @param filter the filter to free"]
    pub fn avfilter_free(filter: *mut AVFilterContext);
}
extern "C" {
    #[doc = " Insert a filter in the middle of an existing link."]
    #[doc = ""]
    #[doc = " @param link the link into which the filter should be inserted"]
    #[doc = " @param filt the filter to be inserted"]
    #[doc = " @param filt_srcpad_idx the input pad on the filter to connect"]
    #[doc = " @param filt_dstpad_idx the output pad on the filter to connect"]
    #[doc = " @return     zero on success"]
    pub fn avfilter_insert_filter(
        link: *mut AVFilterLink,
        filt: *mut AVFilterContext,
        filt_srcpad_idx: ::std::os::raw::c_uint,
        filt_dstpad_idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return AVClass for AVFilterContext."]
    #[doc = ""]
    #[doc = " @see av_opt_find()."]
    pub fn avfilter_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraphInternal {
    _unused: [u8; 0],
}
#[doc = " A function pointer passed to the @ref AVFilterGraph.execute callback to be"]
#[doc = " executed multiple times, possibly in parallel."]
#[doc = ""]
#[doc = " @param ctx the filter context the job belongs to"]
#[doc = " @param arg an opaque parameter passed through from @ref"]
#[doc = "            AVFilterGraph.execute"]
#[doc = " @param jobnr the index of the job being executed"]
#[doc = " @param nb_jobs the total number of jobs"]
#[doc = ""]
#[doc = " @return 0 on success, a negative AVERROR on error"]
pub type avfilter_action_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        arg: *mut ::std::os::raw::c_void,
        jobnr: ::std::os::raw::c_int,
        nb_jobs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A function executing multiple jobs, possibly in parallel."]
#[doc = ""]
#[doc = " @param ctx the filter context to which the jobs belong"]
#[doc = " @param func the function to be called multiple times"]
#[doc = " @param arg the argument to be passed to func"]
#[doc = " @param ret a nb_jobs-sized array to be filled with return values from each"]
#[doc = "            invocation of func"]
#[doc = " @param nb_jobs the number of jobs to execute"]
#[doc = ""]
#[doc = " @return 0 on success, a negative AVERROR on error"]
pub type avfilter_execute_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        func: avfilter_action_func,
        arg: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
        nb_jobs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFilterGraph {
    pub av_class: *const AVClass,
    pub filters: *mut *mut AVFilterContext,
    pub nb_filters: ::std::os::raw::c_uint,
    #[doc = "< sws options to use for the auto-inserted scale filters"]
    pub scale_sws_opts: *mut ::std::os::raw::c_char,
    #[doc = "< libavresample options to use for the auto-inserted resample filters"]
    pub resample_lavr_opts: *mut ::std::os::raw::c_char,
    #[doc = " Type of multithreading allowed for filters in this graph. A combination"]
    #[doc = " of AVFILTER_THREAD_* flags."]
    #[doc = ""]
    #[doc = " May be set by the caller at any point, the setting will apply to all"]
    #[doc = " filters initialized after that. The default is allowing everything."]
    #[doc = ""]
    #[doc = " When a filter in this graph is initialized, this field is combined using"]
    #[doc = " bit AND with AVFilterContext.thread_type to get the final mask used for"]
    #[doc = " determining allowed threading types. I.e. a threading type needs to be"]
    #[doc = " set in both to be allowed."]
    pub thread_type: ::std::os::raw::c_int,
    #[doc = " Maximum number of threads used by filters in this graph. May be set by"]
    #[doc = " the caller before adding any filters to the filtergraph. Zero (the"]
    #[doc = " default) means that the number of threads is determined automatically."]
    pub nb_threads: ::std::os::raw::c_int,
    #[doc = " Opaque object for libavfilter internal use."]
    pub internal: *mut AVFilterGraphInternal,
    #[doc = " Opaque user data. May be set by the caller to an arbitrary value, e.g. to"]
    #[doc = " be used from callbacks like @ref AVFilterGraph.execute."]
    #[doc = " Libavfilter will not touch this field in any way."]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " This callback may be set by the caller immediately after allocating the"]
    #[doc = " graph and before adding any filters to it, to provide a custom"]
    #[doc = " multithreading implementation."]
    #[doc = ""]
    #[doc = " If set, filters with slice threading capability will call this callback"]
    #[doc = " to execute multiple jobs in parallel."]
    #[doc = ""]
    #[doc = " If this field is left unset, libavfilter will use its internal"]
    #[doc = " implementation, which may or may not be multithreaded depending on the"]
    #[doc = " platform and build options."]
    pub execute: avfilter_execute_func,
    #[doc = "< swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions"]
    pub aresample_swr_opts: *mut ::std::os::raw::c_char,
    #[doc = " Private fields"]
    #[doc = ""]
    #[doc = " The following fields are for internal use only."]
    #[doc = " Their type, offset, number and semantic can change without notice."]
    pub sink_links: *mut *mut AVFilterLink,
    pub sink_links_count: ::std::os::raw::c_int,
    pub disable_auto_convert: ::std::os::raw::c_uint,
}
impl Default for AVFilterGraph {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Allocate a filter graph."]
    #[doc = ""]
    #[doc = " @return the allocated filter graph on success or NULL."]
    pub fn avfilter_graph_alloc() -> *mut AVFilterGraph;
}
extern "C" {
    #[doc = " Create a new filter instance in a filter graph."]
    #[doc = ""]
    #[doc = " @param graph graph in which the new filter will be used"]
    #[doc = " @param filter the filter to create an instance of"]
    #[doc = " @param name Name to give to the new instance (will be copied to"]
    #[doc = "             AVFilterContext.name). This may be used by the caller to identify"]
    #[doc = "             different filters, libavfilter itself assigns no semantics to"]
    #[doc = "             this parameter. May be NULL."]
    #[doc = ""]
    #[doc = " @return the context of the newly created filter instance (note that it is"]
    #[doc = "         also retrievable directly through AVFilterGraph.filters or with"]
    #[doc = "         avfilter_graph_get_filter()) on success or NULL on failure."]
    pub fn avfilter_graph_alloc_filter(
        graph: *mut AVFilterGraph,
        filter: *const AVFilter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    #[doc = " Get a filter instance identified by instance name from graph."]
    #[doc = ""]
    #[doc = " @param graph filter graph to search through."]
    #[doc = " @param name filter instance name (should be unique in the graph)."]
    #[doc = " @return the pointer to the found filter instance or NULL if it"]
    #[doc = " cannot be found."]
    pub fn avfilter_graph_get_filter(
        graph: *mut AVFilterGraph,
        name: *const ::std::os::raw::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    #[doc = " Create and add a filter instance into an existing graph."]
    #[doc = " The filter instance is created from the filter filt and inited"]
    #[doc = " with the parameter args. opaque is currently ignored."]
    #[doc = ""]
    #[doc = " In case of success put in *filt_ctx the pointer to the created"]
    #[doc = " filter instance, otherwise set *filt_ctx to NULL."]
    #[doc = ""]
    #[doc = " @param name the instance name to give to the created filter instance"]
    #[doc = " @param graph_ctx the filter graph"]
    #[doc = " @return a negative AVERROR error code in case of failure, a non"]
    #[doc = " negative value otherwise"]
    pub fn avfilter_graph_create_filter(
        filt_ctx: *mut *mut AVFilterContext,
        filt: *const AVFilter,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
        graph_ctx: *mut AVFilterGraph,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable automatic format conversion inside the graph."]
    #[doc = ""]
    #[doc = " Note that format conversion can still happen inside explicitly inserted"]
    #[doc = " scale and aresample filters."]
    #[doc = ""]
    #[doc = " @param flags  any of the AVFILTER_AUTO_CONVERT_* constants"]
    pub fn avfilter_graph_set_auto_convert(
        graph: *mut AVFilterGraph,
        flags: ::std::os::raw::c_uint,
    );
}
#[doc = "< all automatic conversions enabled"]
pub const AVFILTER_AUTO_CONVERT_ALL: ::std::os::raw::c_int = 0;
#[doc = "< all automatic conversions disabled"]
pub const AVFILTER_AUTO_CONVERT_NONE: ::std::os::raw::c_int = -1;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Check validity and configure all the links and formats in the graph."]
    #[doc = ""]
    #[doc = " @param graphctx the filter graph"]
    #[doc = " @param log_ctx context used for logging"]
    #[doc = " @return >= 0 in case of success, a negative AVERROR code otherwise"]
    pub fn avfilter_graph_config(
        graphctx: *mut AVFilterGraph,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a graph, destroy its links, and set *graph to NULL."]
    #[doc = " If *graph is NULL, do nothing."]
    pub fn avfilter_graph_free(graph: *mut *mut AVFilterGraph);
}
#[doc = " A linked-list of the inputs/outputs of the filter chain."]
#[doc = ""]
#[doc = " This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),"]
#[doc = " where it is used to communicate open (unlinked) inputs and outputs from and"]
#[doc = " to the caller."]
#[doc = " This struct specifies, per each not connected pad contained in the graph, the"]
#[doc = " filter context and the pad index required for establishing a link."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFilterInOut {
    #[doc = " unique name for this input/output in the list"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " filter context associated to this input/output"]
    pub filter_ctx: *mut AVFilterContext,
    #[doc = " index of the filt_ctx pad to use for linking"]
    pub pad_idx: ::std::os::raw::c_int,
    #[doc = " next input/input in the list, NULL if this is the last"]
    pub next: *mut AVFilterInOut,
}
impl Default for AVFilterInOut {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Allocate a single AVFilterInOut entry."]
    #[doc = " Must be freed with avfilter_inout_free()."]
    #[doc = " @return allocated AVFilterInOut on success, NULL on failure."]
    pub fn avfilter_inout_alloc() -> *mut AVFilterInOut;
}
extern "C" {
    #[doc = " Free the supplied list of AVFilterInOut and set *inout to NULL."]
    #[doc = " If *inout is NULL, do nothing."]
    pub fn avfilter_inout_free(inout: *mut *mut AVFilterInOut);
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph."]
    #[doc = ""]
    #[doc = " @note The caller must provide the lists of inputs and outputs,"]
    #[doc = " which therefore must be known before calling the function."]
    #[doc = ""]
    #[doc = " @note The inputs parameter describes inputs of the already existing"]
    #[doc = " part of the graph; i.e. from the point of view of the newly created"]
    #[doc = " part, they are outputs. Similarly the outputs parameter describes"]
    #[doc = " outputs of the already existing filters, which are provided as"]
    #[doc = " inputs to the parsed filters."]
    #[doc = ""]
    #[doc = " @param graph   the filter graph where to link the parsed graph context"]
    #[doc = " @param filters string to be parsed"]
    #[doc = " @param inputs  linked list to the inputs of the graph"]
    #[doc = " @param outputs linked list to the outputs of the graph"]
    #[doc = " @return zero on success, a negative AVERROR code on error"]
    pub fn avfilter_graph_parse(
        graph: *mut AVFilterGraph,
        filters: *const ::std::os::raw::c_char,
        inputs: *mut AVFilterInOut,
        outputs: *mut AVFilterInOut,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph."]
    #[doc = ""]
    #[doc = " In the graph filters description, if the input label of the first"]
    #[doc = " filter is not specified, \"in\" is assumed; if the output label of"]
    #[doc = " the last filter is not specified, \"out\" is assumed."]
    #[doc = ""]
    #[doc = " @param graph   the filter graph where to link the parsed graph context"]
    #[doc = " @param filters string to be parsed"]
    #[doc = " @param inputs  pointer to a linked list to the inputs of the graph, may be NULL."]
    #[doc = "                If non-NULL, *inputs is updated to contain the list of open inputs"]
    #[doc = "                after the parsing, should be freed with avfilter_inout_free()."]
    #[doc = " @param outputs pointer to a linked list to the outputs of the graph, may be NULL."]
    #[doc = "                If non-NULL, *outputs is updated to contain the list of open outputs"]
    #[doc = "                after the parsing, should be freed with avfilter_inout_free()."]
    #[doc = " @return non negative on success, a negative AVERROR code on error"]
    pub fn avfilter_graph_parse_ptr(
        graph: *mut AVFilterGraph,
        filters: *const ::std::os::raw::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
        log_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a graph described by a string to a graph."]
    #[doc = ""]
    #[doc = " @param[in]  graph   the filter graph where to link the parsed graph context"]
    #[doc = " @param[in]  filters string to be parsed"]
    #[doc = " @param[out] inputs  a linked list of all free (unlinked) inputs of the"]
    #[doc = "                     parsed graph will be returned here. It is to be freed"]
    #[doc = "                     by the caller using avfilter_inout_free()."]
    #[doc = " @param[out] outputs a linked list of all free (unlinked) outputs of the"]
    #[doc = "                     parsed graph will be returned here. It is to be freed by the"]
    #[doc = "                     caller using avfilter_inout_free()."]
    #[doc = " @return zero on success, a negative AVERROR code on error"]
    #[doc = ""]
    #[doc = " @note This function returns the inputs and outputs that are left"]
    #[doc = " unlinked after parsing the graph and the caller then deals with"]
    #[doc = " them."]
    #[doc = " @note This function makes no reference whatsoever to already"]
    #[doc = " existing parts of the graph and the inputs parameter will on return"]
    #[doc = " contain inputs of the newly parsed part of the graph.  Analogously"]
    #[doc = " the outputs parameter will contain outputs of the newly created"]
    #[doc = " filters."]
    pub fn avfilter_graph_parse2(
        graph: *mut AVFilterGraph,
        filters: *const ::std::os::raw::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a command to one or more filter instances."]
    #[doc = ""]
    #[doc = " @param graph  the filter graph"]
    #[doc = " @param target the filter(s) to which the command should be sent"]
    #[doc = "               \"all\" sends to all filters"]
    #[doc = "               otherwise it can be a filter or filter instance name"]
    #[doc = "               which will send the command to all matching filters."]
    #[doc = " @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only"]
    #[doc = " @param arg    the argument for the command"]
    #[doc = " @param res    a buffer with size res_size where the filter(s) can return a response."]
    #[doc = ""]
    #[doc = " @returns >=0 on success otherwise an error code."]
    #[doc = "              AVERROR(ENOSYS) on unsupported commands"]
    pub fn avfilter_graph_send_command(
        graph: *mut AVFilterGraph,
        target: *const ::std::os::raw::c_char,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_char,
        res_len: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queue a command for one or more filter instances."]
    #[doc = ""]
    #[doc = " @param graph  the filter graph"]
    #[doc = " @param target the filter(s) to which the command should be sent"]
    #[doc = "               \"all\" sends to all filters"]
    #[doc = "               otherwise it can be a filter or filter instance name"]
    #[doc = "               which will send the command to all matching filters."]
    #[doc = " @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only"]
    #[doc = " @param arg    the argument for the command"]
    #[doc = " @param ts     time at which the command should be sent to the filter"]
    #[doc = ""]
    #[doc = " @note As this executes commands after this function returns, no return code"]
    #[doc = "       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported."]
    pub fn avfilter_graph_queue_command(
        graph: *mut AVFilterGraph,
        target: *const ::std::os::raw::c_char,
        cmd: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        ts: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump a graph into a human-readable string representation."]
    #[doc = ""]
    #[doc = " @param graph    the graph to dump"]
    #[doc = " @param options  formatting options; currently ignored"]
    #[doc = " @return  a string, or NULL in case of memory allocation failure;"]
    #[doc = "          the string must be freed using av_free"]
    pub fn avfilter_graph_dump(
        graph: *mut AVFilterGraph,
        options: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Request a frame on the oldest sink link."]
    #[doc = ""]
    #[doc = " If the request returns AVERROR_EOF, try the next."]
    #[doc = ""]
    #[doc = " Note that this function is not meant to be the sole scheduling mechanism"]
    #[doc = " of a filtergraph, only a convenience function to help drain a filtergraph"]
    #[doc = " in a balanced way under normal circumstances."]
    #[doc = ""]
    #[doc = " Also note that AVERROR_EOF does not mean that frames did not arrive on"]
    #[doc = " some of the sinks during the process."]
    #[doc = " When there are multiple sink links, in case the requested link"]
    #[doc = " returns an EOF, this may cause a filter to flush pending frames"]
    #[doc = " which are sent to another sink link, although unrequested."]
    #[doc = ""]
    #[doc = " @return  the return value of ff_request_frame(),"]
    #[doc = "          or AVERROR_EOF if all links returned AVERROR_EOF"]
    pub fn avfilter_graph_request_oldest(graph: *mut AVFilterGraph) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
#[doc = " a pointer to the first option specified in the class if any or NULL"]
#[doc = ""]
#[doc = " @see av_set_default_options()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVOption {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFilterCommand {
    pub _address: u8,
}
