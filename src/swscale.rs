/* automatically generated by rust-bindgen 0.69.4 */

pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const _BSD_SOURCE: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PAGESIZE: u32 = 65536;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 131072;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 32;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const PAGE_SIZE: u32 = 65536;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 1000;
pub const L_ctermid: u32 = 20;
pub const L_cuserid: u32 = 20;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 0;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 59;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 16;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 101;
pub const M_Ef: f64 = 2.718281828459045;
pub const M_LN2f: f64 = 0.6931471805599453;
pub const M_LN10f: f64 = 2.302585092994046;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_LOG2_10f: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const M_PHIf: f64 = 1.618033988749895;
pub const M_PIf: f64 = 3.141592653589793;
pub const M_PI_2f: f64 = 1.5707963267948966;
pub const M_PI_4f: f64 = 0.7853981633974483;
pub const M_1_PIf: f64 = 0.3183098861837907;
pub const M_2_PIf: f64 = 0.6366197723675814;
pub const M_2_SQRTPIf: f64 = 1.1283791670955126;
pub const M_SQRT1_2f: f64 = 0.7071067811865476;
pub const M_SQRT2f: f64 = 1.4142135623730951;
pub const __GNUC_VA_LIST: u32 = 1;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_VIDEO_MAX_PLANES: u32 = 4;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS: u32 = 1;
pub const AV_CHANNEL_LAYOUT_RETYPE_FLAG_CANONICAL: u32 = 2;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_KEY: u32 = 2;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const AV_FRAME_FLAG_INTERLACED: u32 = 8;
pub const AV_FRAME_FLAG_TOP_FIELD_FIRST: u32 = 16;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: u32 = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: u32 = 8;
pub const AV_FRAME_SIDE_DATA_FLAG_UNIQUE: u32 = 1;
pub const AV_FRAME_SIDE_DATA_FLAG_REPLACE: u32 = 2;
pub const LIBSWSCALE_VERSION_MAJOR: u32 = 8;
pub const LIBSWSCALE_VERSION_MINOR: u32 = 2;
pub const LIBSWSCALE_VERSION_MICRO: u32 = 100;
pub const SWS_FAST_BILINEAR: u32 = 1;
pub const SWS_BILINEAR: u32 = 2;
pub const SWS_BICUBIC: u32 = 4;
pub const SWS_X: u32 = 8;
pub const SWS_POINT: u32 = 16;
pub const SWS_AREA: u32 = 32;
pub const SWS_BICUBLIN: u32 = 64;
pub const SWS_GAUSS: u32 = 128;
pub const SWS_SINC: u32 = 256;
pub const SWS_LANCZOS: u32 = 512;
pub const SWS_SPLINE: u32 = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: u32 = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: u32 = 16;
pub const SWS_PARAM_DEFAULT: u32 = 123456;
pub const SWS_PRINT_INFO: u32 = 4096;
pub const SWS_FULL_CHR_H_INT: u32 = 8192;
pub const SWS_FULL_CHR_H_INP: u32 = 16384;
pub const SWS_DIRECT_BGR: u32 = 32768;
pub const SWS_ACCURATE_RND: u32 = 262144;
pub const SWS_BITEXACT: u32 = 524288;
pub const SWS_ERROR_DIFFUSION: u32 = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: u32 = 1;
pub const SWS_CS_FCC: u32 = 4;
pub const SWS_CS_ITU601: u32 = 5;
pub const SWS_CS_ITU624: u32 = 5;
pub const SWS_CS_SMPTE170M: u32 = 5;
pub const SWS_CS_SMPTE240M: u32 = 7;
pub const SWS_CS_DEFAULT: u32 = 5;
pub const SWS_CS_BT2020: u32 = 9;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type time_t = ::std::os::raw::c_longlong;
pub type suseconds_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
extern "C" {
    #[doc = " Return the LIBAVUTIL_VERSION_INT constant."]
    pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return an informative version string. This usually is the actual release\n version number or a git commit description. This string has no fixed format\n and can change any time. It should never be parsed by code."]
    pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavutil build-time configuration."]
    pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libavutil license."]
    pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
#[doc = "< Usually treated as AVMEDIA_TYPE_DATA"]
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
#[doc = "< Opaque data information usually continuous"]
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
#[doc = "< Opaque data information usually sparse"]
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
#[doc = " @addtogroup lavu_media Media Type\n @brief Media Type"]
pub type AVMediaType = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Return a string describing the media_type enum, NULL if media_type\n is unknown."]
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
#[doc = "< Undefined"]
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
#[doc = "< Intra"]
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
#[doc = "< Predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
#[doc = "< Bi-dir predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
#[doc = "< S(GMC)-VOP MPEG-4"]
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
#[doc = "< Switching Intra"]
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
#[doc = "< Switching Predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
#[doc = "< BI type"]
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
#[doc = " @}\n @}\n @defgroup lavu_picture Image related\n\n AVPicture types, pixel formats and basic image planes manipulation.\n\n @{"]
pub type AVPictureType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Return a single letter to describe the given picture type\n pict_type.\n\n @param[in] pict_type the picture type @return a single character\n representing the picture type, '?' if pict_type is unknown"]
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
extern "C" {
    pub static mut errno: ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type __wasi_size_t = ::std::os::raw::c_ulong;
#[doc = " Non-negative file size or length of a region within a file."]
pub type __wasi_filesize_t = u64;
#[doc = " Timestamp in nanoseconds."]
pub type __wasi_timestamp_t = u64;
#[doc = " Identifiers for clocks."]
pub type __wasi_clockid_t = u32;
#[doc = " Error codes returned by functions.\n Not all of these error codes are returned by the functions provided by this\n API; some are used in higher-level library layers, and others are provided\n merely for alignment with POSIX."]
pub type __wasi_errno_t = u16;
#[doc = " File descriptor rights, determining which actions may be performed."]
pub type __wasi_rights_t = u64;
#[doc = " A file descriptor handle."]
pub type __wasi_fd_t = ::std::os::raw::c_int;
#[doc = " A region of memory for scatter/gather reads."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_iovec_t {
    #[doc = " The address of the buffer to be filled."]
    pub buf: *mut u8,
    #[doc = " The length of the buffer to be filled."]
    pub buf_len: __wasi_size_t,
}
impl Default for __wasi_iovec_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A region of memory for scatter/gather writes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_ciovec_t {
    #[doc = " The address of the buffer to be written."]
    pub buf: *const u8,
    #[doc = " The length of the buffer to be written."]
    pub buf_len: __wasi_size_t,
}
impl Default for __wasi_ciovec_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Relative offset within a file."]
pub type __wasi_filedelta_t = i64;
#[doc = " The position relative to which to set the offset of the file descriptor."]
pub type __wasi_whence_t = u8;
#[doc = " A reference to the offset of a directory entry.\n\n The value 0 signifies the start of the directory."]
pub type __wasi_dircookie_t = u64;
#[doc = " The type for the `dirent::d_namlen` field of `dirent` struct."]
pub type __wasi_dirnamlen_t = u32;
#[doc = " File serial number that is unique within its file system."]
pub type __wasi_inode_t = u64;
#[doc = " The type of a file descriptor or file."]
pub type __wasi_filetype_t = u8;
#[doc = " A directory entry."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_dirent_t {
    #[doc = " The offset of the next directory entry stored in this directory."]
    pub d_next: __wasi_dircookie_t,
    #[doc = " The serial number of the file referred to by this directory entry."]
    pub d_ino: __wasi_inode_t,
    #[doc = " The length of the name of the directory entry."]
    pub d_namlen: __wasi_dirnamlen_t,
    #[doc = " The type of the file referred to by this directory entry."]
    pub d_type: __wasi_filetype_t,
}
#[doc = " File or memory access pattern advisory information."]
pub type __wasi_advice_t = u8;
#[doc = " File descriptor flags."]
pub type __wasi_fdflags_t = u16;
#[doc = " File descriptor attributes."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_fdstat_t {
    #[doc = " File type."]
    pub fs_filetype: __wasi_filetype_t,
    #[doc = " File descriptor flags."]
    pub fs_flags: __wasi_fdflags_t,
    #[doc = " Rights that apply to this file descriptor."]
    pub fs_rights_base: __wasi_rights_t,
    #[doc = " Maximum set of rights that may be installed on new file descriptors that\n are created through this file descriptor, e.g., through `path_open`."]
    pub fs_rights_inheriting: __wasi_rights_t,
}
#[doc = " Identifier for a device containing a file system. Can be used in combination\n with `inode` to uniquely identify a file or directory in the filesystem."]
pub type __wasi_device_t = u64;
#[doc = " Which file time attributes to adjust."]
pub type __wasi_fstflags_t = u16;
#[doc = " Flags determining the method of how paths are resolved."]
pub type __wasi_lookupflags_t = u32;
#[doc = " Open flags used by `path_open`."]
pub type __wasi_oflags_t = u16;
#[doc = " Number of hard links to an inode."]
pub type __wasi_linkcount_t = u64;
#[doc = " File attributes."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_filestat_t {
    #[doc = " Device ID of device containing the file."]
    pub dev: __wasi_device_t,
    #[doc = " File serial number."]
    pub ino: __wasi_inode_t,
    #[doc = " File type."]
    pub filetype: __wasi_filetype_t,
    #[doc = " Number of hard links to the file."]
    pub nlink: __wasi_linkcount_t,
    #[doc = " For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link."]
    pub size: __wasi_filesize_t,
    #[doc = " Last data access timestamp."]
    pub atim: __wasi_timestamp_t,
    #[doc = " Last data modification timestamp."]
    pub mtim: __wasi_timestamp_t,
    #[doc = " Last file status change timestamp."]
    pub ctim: __wasi_timestamp_t,
}
#[doc = " User-provided value that may be attached to objects that is retained when\n extracted from the implementation."]
pub type __wasi_userdata_t = u64;
#[doc = " Type of a subscription to an event or its occurrence."]
pub type __wasi_eventtype_t = u8;
#[doc = " The state of the file descriptor subscribed to with\n `eventtype::fd_read` or `eventtype::fd_write`."]
pub type __wasi_eventrwflags_t = u16;
#[doc = " The contents of an `event` when type is `eventtype::fd_read` or\n `eventtype::fd_write`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_event_fd_readwrite_t {
    #[doc = " The number of bytes available for reading or writing."]
    pub nbytes: __wasi_filesize_t,
    #[doc = " The state of the file descriptor."]
    pub flags: __wasi_eventrwflags_t,
}
#[doc = " An event that occurred."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_event_t {
    #[doc = " User-provided value that got attached to `subscription::userdata`."]
    pub userdata: __wasi_userdata_t,
    #[doc = " If non-zero, an error that occurred while processing the subscription request."]
    pub error: __wasi_errno_t,
    #[doc = " The type of event that occured"]
    pub type_: __wasi_eventtype_t,
    #[doc = " The contents of the event, if it is an `eventtype::fd_read` or\n `eventtype::fd_write`. `eventtype::clock` events ignore this field."]
    pub fd_readwrite: __wasi_event_fd_readwrite_t,
}
#[doc = " Flags determining how to interpret the timestamp provided in\n `subscription_clock::timeout`."]
pub type __wasi_subclockflags_t = u16;
#[doc = " The contents of a `subscription` when type is `eventtype::clock`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_subscription_clock_t {
    #[doc = " The clock against which to compare the timestamp."]
    pub id: __wasi_clockid_t,
    #[doc = " The absolute or relative timestamp."]
    pub timeout: __wasi_timestamp_t,
    #[doc = " The amount of time that the implementation may wait additionally\n to coalesce with other events."]
    pub precision: __wasi_timestamp_t,
    #[doc = " Flags specifying whether the timeout is absolute or relative"]
    pub flags: __wasi_subclockflags_t,
}
#[doc = " The contents of a `subscription` when type is type is\n `eventtype::fd_read` or `eventtype::fd_write`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_subscription_fd_readwrite_t {
    #[doc = " The file descriptor on which to wait for it to become ready for reading or writing."]
    pub file_descriptor: __wasi_fd_t,
}
#[doc = " The contents of a `subscription`."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_subscription_u_u_t {
    pub clock: __wasi_subscription_clock_t,
    pub fd_read: __wasi_subscription_fd_readwrite_t,
    pub fd_write: __wasi_subscription_fd_readwrite_t,
}
impl Default for __wasi_subscription_u_u_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_u_t {
    pub tag: u8,
    pub u: __wasi_subscription_u_u_t,
}
impl Default for __wasi_subscription_u_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Subscription to an event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_t {
    #[doc = " User-provided value that is attached to the subscription in the\n implementation and returned through `event::userdata`."]
    pub userdata: __wasi_userdata_t,
    #[doc = " The type of the event to which to subscribe, and its contents"]
    pub u: __wasi_subscription_u_t,
}
impl Default for __wasi_subscription_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Exit code generated by a process when exiting."]
pub type __wasi_exitcode_t = u32;
#[doc = " Flags provided to `sock_recv`."]
pub type __wasi_riflags_t = u16;
#[doc = " Flags returned by `sock_recv`."]
pub type __wasi_roflags_t = u16;
#[doc = " Flags provided to `sock_send`. As there are currently no flags\n defined, it must be set to zero."]
pub type __wasi_siflags_t = u16;
#[doc = " Which channels on a socket to shut down."]
pub type __wasi_sdflags_t = u8;
#[doc = " Identifiers for preopened capabilities."]
pub type __wasi_preopentype_t = u8;
#[doc = " The contents of a $prestat when type is `preopentype::dir`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_prestat_dir_t {
    #[doc = " The length of the directory name for use with `fd_prestat_dir_name`."]
    pub pr_name_len: __wasi_size_t,
}
#[doc = " Information about a pre-opened capability."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_prestat_u_t {
    pub dir: __wasi_prestat_dir_t,
}
impl Default for __wasi_prestat_u_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_prestat_t {
    pub tag: u8,
    pub u: __wasi_prestat_u_t,
}
impl Default for __wasi_prestat_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = " Read command-line argument data.\n The size of the array should match that returned by `args_sizes_get`.\n Each argument is expected to be `\\0` terminated."]
    pub fn __wasi_args_get(argv: *mut *mut u8, argv_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return command-line argument data sizes.\n @return\n Returns the number of arguments and the size of the argument string\n data, or an error."]
    pub fn __wasi_args_sizes_get(
        retptr0: *mut __wasi_size_t,
        retptr1: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read environment variable data.\n The sizes of the buffers should match that returned by `environ_sizes_get`.\n Key/value pairs are expected to be joined with `=`s, and terminated with `\\0`s."]
    pub fn __wasi_environ_get(environ: *mut *mut u8, environ_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return environment variable data sizes.\n @return\n Returns the number of environment variable arguments and the size of the\n environment variable data."]
    pub fn __wasi_environ_sizes_get(
        retptr0: *mut __wasi_size_t,
        retptr1: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the resolution of a clock.\n Implementations are required to provide a non-zero value for supported clocks. For unsupported clocks,\n return `errno::inval`.\n Note: This is similar to `clock_getres` in POSIX.\n @return\n The resolution of the clock, or an error if one happened."]
    pub fn __wasi_clock_res_get(
        id: __wasi_clockid_t,
        retptr0: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the time value of a clock.\n Note: This is similar to `clock_gettime` in POSIX.\n @return\n The time value of the clock."]
    pub fn __wasi_clock_time_get(
        id: __wasi_clockid_t,
        precision: __wasi_timestamp_t,
        retptr0: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Provide file advisory information on a file descriptor.\n Note: This is similar to `posix_fadvise` in POSIX."]
    pub fn __wasi_fd_advise(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
        advice: __wasi_advice_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Force the allocation of space in a file.\n Note: This is similar to `posix_fallocate` in POSIX."]
    pub fn __wasi_fd_allocate(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Close a file descriptor.\n Note: This is similar to `close` in POSIX."]
    pub fn __wasi_fd_close(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Synchronize the data of a file to disk.\n Note: This is similar to `fdatasync` in POSIX."]
    pub fn __wasi_fd_datasync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Get the attributes of a file descriptor.\n Note: This returns similar flags to `fsync(fd, F_GETFL)` in POSIX, as well as additional fields.\n @return\n The buffer where the file descriptor's attributes are stored."]
    pub fn __wasi_fd_fdstat_get(fd: __wasi_fd_t, retptr0: *mut __wasi_fdstat_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the flags associated with a file descriptor.\n Note: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX."]
    pub fn __wasi_fd_fdstat_set_flags(fd: __wasi_fd_t, flags: __wasi_fdflags_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the rights associated with a file descriptor.\n This can only be used to remove rights, and returns `errno::notcapable` if called in a way that would attempt to add rights"]
    pub fn __wasi_fd_fdstat_set_rights(
        fd: __wasi_fd_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inheriting: __wasi_rights_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the attributes of an open file.\n @return\n The buffer where the file's attributes are stored."]
    pub fn __wasi_fd_filestat_get(
        fd: __wasi_fd_t,
        retptr0: *mut __wasi_filestat_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros.\n Note: This is similar to `ftruncate` in POSIX."]
    pub fn __wasi_fd_filestat_set_size(fd: __wasi_fd_t, size: __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the timestamps of an open file or directory.\n Note: This is similar to `futimens` in POSIX."]
    pub fn __wasi_fd_filestat_set_times(
        fd: __wasi_fd_t,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read from a file descriptor, without using and updating the file descriptor's offset.\n Note: This is similar to `preadv` in POSIX.\n @return\n The number of bytes read."]
    pub fn __wasi_fd_pread(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return a description of the given preopened file descriptor.\n @return\n The buffer where the description is stored."]
    pub fn __wasi_fd_prestat_get(fd: __wasi_fd_t, retptr0: *mut __wasi_prestat_t)
        -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return a description of the given preopened file descriptor."]
    pub fn __wasi_fd_prestat_dir_name(
        fd: __wasi_fd_t,
        path: *mut u8,
        path_len: __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Write to a file descriptor, without using and updating the file descriptor's offset.\n Note: This is similar to `pwritev` in POSIX.\n @return\n The number of bytes written."]
    pub fn __wasi_fd_pwrite(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read from a file descriptor.\n Note: This is similar to `readv` in POSIX.\n @return\n The number of bytes read."]
    pub fn __wasi_fd_read(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read directory entries from a directory.\n When successful, the contents of the output buffer consist of a sequence of\n directory entries. Each directory entry consists of a `dirent` object,\n followed by `dirent::d_namlen` bytes holding the name of the directory\n entry.\n This function fills the output buffer as much as possible, potentially\n truncating the last directory entry. This allows the caller to grow its\n read buffer size in case it's too small to fit a single large directory\n entry, or skip the oversized directory entry.\n @return\n The number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached."]
    pub fn __wasi_fd_readdir(
        fd: __wasi_fd_t,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        cookie: __wasi_dircookie_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Atomically replace a file descriptor by renumbering another file descriptor.\n Due to the strong focus on thread safety, this environment does not provide\n a mechanism to duplicate or renumber a file descriptor to an arbitrary\n number, like `dup2()`. This would be prone to race conditions, as an actual\n file descriptor with the same number could be allocated by a different\n thread at the same time.\n This function provides a way to atomically renumber file descriptors, which\n would disappear if `dup2()` were to be removed entirely."]
    pub fn __wasi_fd_renumber(fd: __wasi_fd_t, to: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Move the offset of a file descriptor.\n Note: This is similar to `lseek` in POSIX.\n @return\n The new offset of the file descriptor, relative to the start of the file."]
    pub fn __wasi_fd_seek(
        fd: __wasi_fd_t,
        offset: __wasi_filedelta_t,
        whence: __wasi_whence_t,
        retptr0: *mut __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Synchronize the data and metadata of a file to disk.\n Note: This is similar to `fsync` in POSIX."]
    pub fn __wasi_fd_sync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the current offset of a file descriptor.\n Note: This is similar to `lseek(fd, 0, SEEK_CUR)` in POSIX.\n @return\n The current offset of the file descriptor, relative to the start of the file."]
    pub fn __wasi_fd_tell(fd: __wasi_fd_t, retptr0: *mut __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Write to a file descriptor.\n Note: This is similar to `writev` in POSIX."]
    pub fn __wasi_fd_write(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Create a directory.\n Note: This is similar to `mkdirat` in POSIX."]
    pub fn __wasi_path_create_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the attributes of a file or directory.\n Note: This is similar to `stat` in POSIX.\n @return\n The buffer where the file's attributes are stored."]
    pub fn __wasi_path_filestat_get(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        retptr0: *mut __wasi_filestat_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the timestamps of a file or directory.\n Note: This is similar to `utimensat` in POSIX."]
    pub fn __wasi_path_filestat_set_times(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Create a hard link.\n Note: This is similar to `linkat` in POSIX."]
    pub fn __wasi_path_link(
        old_fd: __wasi_fd_t,
        old_flags: __wasi_lookupflags_t,
        old_path: *const ::std::os::raw::c_char,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Open a file or directory.\n The returned file descriptor is not guaranteed to be the lowest-numbered\n file descriptor not currently open; it is randomized to prevent\n applications from depending on making assumptions about indexes, since this\n is error-prone in multi-threaded contexts. The returned file descriptor is\n guaranteed to be less than 2**31.\n Note: This is similar to `openat` in POSIX.\n @return\n The file descriptor of the file that has been opened."]
    pub fn __wasi_path_open(
        fd: __wasi_fd_t,
        dirflags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        oflags: __wasi_oflags_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inheriting: __wasi_rights_t,
        fdflags: __wasi_fdflags_t,
        retptr0: *mut __wasi_fd_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read the contents of a symbolic link.\n Note: This is similar to `readlinkat` in POSIX.\n @return\n The number of bytes placed in the buffer."]
    pub fn __wasi_path_readlink(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Remove a directory.\n Return `errno::notempty` if the directory is not empty.\n Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX."]
    pub fn __wasi_path_remove_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Rename a file or directory.\n Note: This is similar to `renameat` in POSIX."]
    pub fn __wasi_path_rename(
        fd: __wasi_fd_t,
        old_path: *const ::std::os::raw::c_char,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Create a symbolic link.\n Note: This is similar to `symlinkat` in POSIX."]
    pub fn __wasi_path_symlink(
        old_path: *const ::std::os::raw::c_char,
        fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Unlink a file.\n Return `errno::isdir` if the path refers to a directory.\n Note: This is similar to `unlinkat(fd, path, 0)` in POSIX."]
    pub fn __wasi_path_unlink_file(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Concurrently poll for the occurrence of a set of events.\n @return\n The number of events stored."]
    pub fn __wasi_poll_oneoff(
        in_: *const __wasi_subscription_t,
        out: *mut __wasi_event_t,
        nsubscriptions: __wasi_size_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[doc = " Terminate the process normally. An exit code of 0 indicates successful\n termination of the program. The meanings of other values is dependent on\n the environment."]
    pub fn __wasi_proc_exit(rval: __wasi_exitcode_t) -> !;
}
extern "C" {
    #[must_use]
    #[doc = " Temporarily yield execution of the calling thread.\n Note: This is similar to `sched_yield` in POSIX."]
    pub fn __wasi_sched_yield() -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Write high-quality random data into a buffer.\n This function blocks when the implementation is unable to immediately\n provide sufficient high-quality random data.\n This function may execute slowly, so when large mounts of random data are\n required, it's advisable to use this function to seed a pseudo-random\n number generator, rather than to provide the random data directly."]
    pub fn __wasi_random_get(buf: *mut u8, buf_len: __wasi_size_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Accept a new incoming connection.\n Note: This is similar to `accept` in POSIX.\n @return\n New socket connection"]
    pub fn __wasi_sock_accept(
        fd: __wasi_fd_t,
        flags: __wasi_fdflags_t,
        retptr0: *mut __wasi_fd_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Receive a message from a socket.\n Note: This is similar to `recv` in POSIX, though it also supports reading\n the data into multiple buffers in the manner of `readv`.\n @return\n Number of bytes stored in ri_data and message flags."]
    pub fn __wasi_sock_recv(
        fd: __wasi_fd_t,
        ri_data: *const __wasi_iovec_t,
        ri_data_len: usize,
        ri_flags: __wasi_riflags_t,
        retptr0: *mut __wasi_size_t,
        retptr1: *mut __wasi_roflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Send a message on a socket.\n Note: This is similar to `send` in POSIX, though it also supports writing\n the data from multiple buffers in the manner of `writev`.\n @return\n Number of bytes transmitted."]
    pub fn __wasi_sock_send(
        fd: __wasi_fd_t,
        si_data: *const __wasi_ciovec_t,
        si_data_len: usize,
        si_flags: __wasi_siflags_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Shut down socket send and receive channels.\n Note: This is similar to `shutdown` in POSIX."]
    pub fn __wasi_sock_shutdown(fd: __wasi_fd_t, how: __wasi_sdflags_t) -> __wasi_errno_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expl(arg1: u128) -> u128;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalbf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
extern "C" {
    pub fn significandf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
pub type off_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type __isoc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::std::os::raw::c_char; 16usize],
    pub __lldata: ::std::os::raw::c_longlong,
    pub __align: f64,
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fpos_t = _G_fpos64_t;
extern "C" {
    pub static stdin: *mut FILE;
}
extern "C" {
    pub static stdout: *mut FILE;
}
extern "C" {
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE);
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char, arg3: usize);
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __isoc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[must_use]
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[must_use]
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4random_uniform(arg1: u32) -> u32;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __dst: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    #[doc = " Put a description of the AVERROR code errnum in errbuf.\n In case of failure the global variable errno is set to indicate the\n error. Even in case of failure av_strerror() will print a generic\n error message indicating the errnum provided to errbuf.\n\n @param errnum      error code to describe\n @param errbuf      buffer to which description is written\n @param errbuf_size the size in bytes of errbuf\n @return 0 on success, a negative value if a description for errnum\n cannot be found"]
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses\n (including vectors if available on the CPU).\n\n @param size Size in bytes for the memory block to be allocated\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n @see av_mallocz()"]
    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block with alignment suitable for all memory accesses\n (including vectors if available on the CPU) and zero all the bytes of the\n block.\n\n @param size Size in bytes for the memory block to be allocated\n @return Pointer to the allocated block, or `NULL` if it cannot be allocated\n @see av_malloc()"]
    pub fn av_mallocz(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_malloc().\n\n The allocated memory will have size `size * nmemb` bytes.\n\n @param nmemb Number of element\n @param size  Size of a single element\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n @see av_malloc()"]
    pub fn av_malloc_array(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a memory block for an array with av_mallocz().\n\n The allocated memory will have size `size * nmemb` bytes.\n\n @param nmemb Number of elements\n @param size  Size of the single element\n @return Pointer to the allocated block, or `NULL` if the block cannot\n         be allocated\n\n @see av_mallocz()\n @see av_malloc_array()"]
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory.\n\n If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or\n shrink that block of memory according to `size`.\n\n @param ptr  Pointer to a memory block already allocated with\n             av_realloc() or `NULL`\n @param size Size in bytes of the memory block to be allocated or\n             reallocated\n\n @return Pointer to a newly-reallocated block or `NULL` if the block\n         cannot be reallocated\n\n @warning Unlike av_malloc(), the returned pointer is not guaranteed to be\n          correctly aligned. The returned pointer must be freed after even\n          if size is zero.\n @see av_fast_realloc()\n @see av_reallocp()"]
    pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: usize)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[must_use]
    #[doc = " Allocate, reallocate, or free a block of memory through a pointer to a\n pointer.\n\n If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n zero, free the memory block pointed to by `*ptr`. Otherwise, expand or\n shrink that block of memory according to `size`.\n\n @param[in,out] ptr  Pointer to a pointer to a memory block already allocated\n                     with av_realloc(), or a pointer to `NULL`. The pointer\n                     is updated on success, or freed on failure.\n @param[in]     size Size in bytes for the memory block to be allocated or\n                     reallocated\n\n @return Zero on success, an AVERROR error code on failure\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned."]
    pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free a block of memory.\n\n This function does the same thing as av_realloc(), except:\n - It takes two size arguments and allocates `nelem * elsize` bytes,\n   after checking the result of the multiplication for integer overflow.\n - It frees the input block in case of failure, thus avoiding the memory\n   leak with the classic\n   @code{.c}\n   buf = realloc(buf);\n   if (!buf)\n       return -1;\n   @endcode\n   pattern."]
    pub fn av_realloc_f(
        ptr: *mut ::std::os::raw::c_void,
        nelem: usize,
        elsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate, or free an array.\n\n If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.\n\n @param ptr   Pointer to a memory block already allocated with\n              av_realloc() or `NULL`\n @param nmemb Number of elements in the array\n @param size  Size of the single element of the array\n\n @return Pointer to a newly-reallocated block or NULL if the block\n         cannot be reallocated\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned. The returned pointer must be freed after even if\n          nmemb is zero.\n @see av_reallocp_array()"]
    pub fn av_realloc_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate, reallocate an array through a pointer to a pointer.\n\n If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.\n\n @param[in,out] ptr   Pointer to a pointer to a memory block already\n                      allocated with av_realloc(), or a pointer to `NULL`.\n                      The pointer is updated on success, or freed on failure.\n @param[in]     nmemb Number of elements\n @param[in]     size  Size of the single element\n\n @return Zero on success, an AVERROR error code on failure\n\n @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n          correctly aligned. *ptr must be freed after even if nmemb is zero."]
    pub fn av_reallocp_array(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reallocate the given buffer if it is not large enough, otherwise do nothing.\n\n If the given buffer is `NULL`, then a new uninitialized buffer is allocated.\n\n If the given buffer is not large enough, and reallocation fails, `NULL` is\n returned and `*size` is set to 0, but the original buffer is not changed or\n freed.\n\n A typical use pattern follows:\n\n @code{.c}\n uint8_t *buf = ...;\n uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);\n if (!new_buf) {\n     // Allocation failed; clean up original buffer\n     av_freep(&buf);\n     return AVERROR(ENOMEM);\n }\n @endcode\n\n @param[in,out] ptr      Already allocated buffer, or `NULL`\n @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `ptr`\n @return `ptr` if the buffer is large enough, a pointer to newly reallocated\n         buffer if the buffer was not large enough, or `NULL` in case of\n         error\n @see av_realloc()\n @see av_fast_malloc()"]
    pub fn av_fast_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a buffer, reusing the given one if large enough.\n\n Contrary to av_fast_realloc(), the current buffer contents might not be\n preserved and on error the old buffer is freed, thus no special handling to\n avoid memleaks is necessary.\n\n `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n `size_needed` is greater than 0.\n\n @code{.c}\n uint8_t *buf = ...;\n av_fast_malloc(&buf, &current_size, size_needed);\n if (!buf) {\n     // Allocation failed; buf already freed\n     return AVERROR(ENOMEM);\n }\n @endcode\n\n @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n                         `*ptr` will be overwritten with pointer to new\n                         buffer on success or `NULL` on failure\n @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `*ptr`\n @see av_realloc()\n @see av_fast_mallocz()"]
    pub fn av_fast_malloc(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Allocate and clear a buffer, reusing the given one if large enough.\n\n Like av_fast_malloc(), but all newly allocated space is initially cleared.\n Reused buffer is not cleared.\n\n `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n `size_needed` is greater than 0.\n\n @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n                         `*ptr` will be overwritten with pointer to new\n                         buffer on success or `NULL` on failure\n @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n                         updated to the new allocated size, in particular 0\n                         in case of failure.\n @param[in]     min_size Desired minimal size of buffer `*ptr`\n @see av_fast_malloc()"]
    pub fn av_fast_mallocz(
        ptr: *mut ::std::os::raw::c_void,
        size: *mut ::std::os::raw::c_uint,
        min_size: usize,
    );
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()\n or av_realloc() family.\n\n @param ptr Pointer to the memory block which should be freed.\n\n @note `ptr = NULL` is explicitly allowed.\n @note It is recommended that you use av_freep() instead, to prevent leaving\n       behind dangling pointers.\n @see av_freep()"]
    pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Free a memory block which has been allocated with a function of av_malloc()\n or av_realloc() family, and set the pointer pointing to it to `NULL`.\n\n @code{.c}\n uint8_t *buf = av_malloc(16);\n av_free(buf);\n // buf now contains a dangling pointer to freed memory, and accidental\n // dereference of buf will result in a use-after-free, which may be a\n // security risk.\n\n uint8_t *buf = av_malloc(16);\n av_freep(&buf);\n // buf is now NULL, and accidental dereference will only result in a\n // NULL-pointer dereference.\n @endcode\n\n @param ptr Pointer to the pointer to the memory block which should be freed\n @note `*ptr = NULL` is safe and leads to no action.\n @see av_free()"]
    pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Duplicate a string.\n\n @param s String to be duplicated\n @return Pointer to a newly-allocated string containing a\n         copy of `s` or `NULL` if the string cannot be allocated\n @see av_strndup()"]
    pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate a substring of a string.\n\n @param s   String to be duplicated\n @param len Maximum length of the resulting string (not counting the\n            terminating byte)\n @return Pointer to a newly-allocated string containing a\n         substring of `s` or `NULL` if the string cannot be allocated"]
    pub fn av_strndup(s: *const ::std::os::raw::c_char, len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Duplicate a buffer with av_malloc().\n\n @param p    Buffer to be duplicated\n @param size Size in bytes of the buffer copied\n @return Pointer to a newly allocated buffer containing a\n         copy of `p` or `NULL` if the buffer cannot be allocated"]
    pub fn av_memdup(p: *const ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Overlapping memcpy() implementation.\n\n @param dst  Destination buffer\n @param back Number of bytes back to start copying (i.e. the initial size of\n             the overlapping window); must be > 0\n @param cnt  Number of bytes to copy; must be >= 0\n\n @note `cnt > back` is valid, this will copy the bytes we just copied,\n       thus creating a repeating pattern with a period length of `back`."]
    pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Add the pointer to an element to a dynamic array.\n\n The array to grow is supposed to be an array of pointers to\n structures, and the element to add must be a pointer to an already\n allocated structure.\n\n The array is reallocated when its size reaches powers of 2.\n Therefore, the amortized cost of adding an element is constant.\n\n In case of success, the pointer to the array is updated in order to\n point to the new grown array, and the number pointed to by `nb_ptr`\n is incremented.\n In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n `*nb_ptr` is set to 0.\n\n @param[in,out] tab_ptr Pointer to the array to grow\n @param[in,out] nb_ptr  Pointer to the number of elements in the array\n @param[in]     elem    Element to add\n @see av_dynarray_add_nofree(), av_dynarray2_add()"]
    pub fn av_dynarray_add(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[must_use]
    #[doc = " Add an element to a dynamic array.\n\n Function has the same functionality as av_dynarray_add(),\n but it doesn't free memory on fails. It returns error code\n instead and leave current buffer untouched.\n\n @return >=0 on success, negative otherwise\n @see av_dynarray_add(), av_dynarray2_add()"]
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an element of size `elem_size` to a dynamic array.\n\n The array is reallocated when its number of elements reaches powers of 2.\n Therefore, the amortized cost of adding an element is constant.\n\n In case of success, the pointer to the array is updated in order to\n point to the new grown array, and the number pointed to by `nb_ptr`\n is incremented.\n In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n `*nb_ptr` is set to 0.\n\n @param[in,out] tab_ptr   Pointer to the array to grow\n @param[in,out] nb_ptr    Pointer to the number of elements in the array\n @param[in]     elem_size Size in bytes of an element in the array\n @param[in]     elem_data Pointer to the data of the element to add. If\n                          `NULL`, the space of the newly added element is\n                          allocated but left uninitialized.\n\n @return Pointer to the data of the element to copy in the newly allocated\n         space\n @see av_dynarray_add(), av_dynarray_add_nofree()"]
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut ::std::os::raw::c_void,
        nb_ptr: *mut ::std::os::raw::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Multiply two `size_t` values checking for overflow.\n\n @param[in]  a   Operand of multiplication\n @param[in]  b   Operand of multiplication\n @param[out] r   Pointer to the result of the operation\n @return 0 on success, AVERROR(EINVAL) on overflow"]
    pub fn av_size_mult(a: usize, b: usize, r: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the maximum size that may be allocated in one block.\n\n The value specified with this function is effective for all libavutil's @ref\n lavu_mem_funcs \"heap management functions.\"\n\n By default, the max value is defined as `INT_MAX`.\n\n @param max Value to be set as the new maximum size\n\n @warning Exercise extreme caution when using this function. Don't touch\n          this if you do not understand the full consequence of doing so."]
    pub fn av_max_alloc(max: usize);
}
extern "C" {
    pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[doc = " Rational number (pair of numerator and denominator)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVRational {
    #[doc = "< Numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = "< Denominator"]
    pub den: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " Reduce a fraction.\n\n This is useful for framerate calculations.\n\n @param[out] dst_num Destination numerator\n @param[out] dst_den Destination denominator\n @param[in]      num Source numerator\n @param[in]      den Source denominator\n @param[in]      max Maximum allowed values for `dst_num` & `dst_den`\n @return 1 if the operation is exact, 0 otherwise"]
    pub fn av_reduce(
        dst_num: *mut ::std::os::raw::c_int,
        dst_den: *mut ::std::os::raw::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Multiply two rationals.\n @param b First rational\n @param c Second rational\n @return b*c"]
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Divide one rational by another.\n @param b First rational\n @param c Second rational\n @return b/c"]
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Add two rationals.\n @param b First rational\n @param c Second rational\n @return b+c"]
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Subtract one rational from another.\n @param b First rational\n @param c Second rational\n @return b-c"]
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    #[doc = " Convert a double precision floating point number to a rational.\n\n In case of infinity, the returned value is expressed as `{1, 0}` or\n `{-1, 0}` depending on the sign.\n\n In general rational numbers with |num| <= 1<<26 && |den| <= 1<<26\n can be recovered exactly from their double representation.\n (no exceptions were found within 1B random ones)\n\n @param d   `double` to convert\n @param max Maximum allowed numerator and denominator\n @return `d` in AVRational form\n @see av_q2d()"]
    pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
    #[doc = " Find which of the two rationals is closer to another rational.\n\n @param q     Rational to be compared against\n @param q1    Rational to be tested\n @param q2    Rational to be tested\n @return One of the following values:\n         - 1 if `q1` is nearer to `q` than `q2`\n         - -1 if `q2` is nearer to `q` than `q1`\n         - 0 if they have the same distance"]
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the value in a list of rationals nearest a given reference rational.\n\n @param q      Reference rational\n @param q_list Array of rationals terminated by `{0, 0}`\n @return Index of the nearest value found in the array"]
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point\n format.\n\n @param q Rational to be converted\n @return Equivalent floating-point value, expressed as an unsigned 32-bit\n         integer.\n @note The returned value is platform-indepedant."]
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
    #[doc = " Return the best rational so that a and b are multiple of it.\n If the resulting denominator is larger than max_den, return def."]
    pub fn av_gcd_q(
        a: AVRational,
        b: AVRational,
        max_den: ::std::os::raw::c_int,
        def: AVRational,
    ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
}
impl Default for av_intfloat32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
}
impl Default for av_intfloat64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Round toward zero."]
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
#[doc = "< Round away from zero."]
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
#[doc = "< Round toward -infinity."]
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
#[doc = "< Round toward +infinity."]
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
#[doc = "< Round to nearest and halfway cases away from zero."]
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
#[doc = " Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through\n unchanged, avoiding special cases for #AV_NOPTS_VALUE.\n\n Unlike other values of the enumeration AVRounding, this value is a\n bitmask that must be used in conjunction with another value of the\n enumeration through a bitwise OR, in order to set behavior for normal\n cases.\n\n @code{.c}\n av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n // Rescaling 3:\n //     Calculating 3 * 1 / 2\n //     3 / 2 is rounded up to 2\n //     => 2\n\n av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);\n // Rescaling AV_NOPTS_VALUE:\n //     AV_NOPTS_VALUE == INT64_MIN\n //     AV_NOPTS_VALUE is passed through\n //     => AV_NOPTS_VALUE\n @endcode"]
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
#[doc = " Rounding methods."]
pub type AVRounding = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Compute the greatest common divisor of two integer operands.\n\n @param a Operand\n @param b Operand\n @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;\n if a == 0 and b == 0, returns 0."]
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with rounding to nearest.\n\n The operation is mathematically equivalent to `a * b / c`, but writing that\n directly can overflow.\n\n This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.\n\n @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer with specified rounding.\n\n The operation is mathematically equivalent to `a * b / c`, but writing that\n directly can overflow, and does not support different rounding methods.\n If the result is not representable then INT64_MIN is returned.\n\n @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()"]
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers.\n\n The operation is mathematically equivalent to `a * bq / cq`.\n\n This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.\n\n @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()"]
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    #[doc = " Rescale a 64-bit integer by 2 rational numbers with specified rounding.\n\n The operation is mathematically equivalent to `a * bq / cq`.\n\n @see av_rescale(), av_rescale_rnd(), av_rescale_q()"]
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    #[doc = " Compare two timestamps each in its own time base.\n\n @return One of the following values:\n         - -1 if `ts_a` is before `ts_b`\n         - 1 if `ts_a` is after `ts_b`\n         - 0 if they represent the same position\n\n @warning\n The result of the function is undefined if one of the timestamps is outside\n the `int64_t` range when represented in the other's timebase."]
    pub fn av_compare_ts(
        ts_a: i64,
        tb_a: AVRational,
        ts_b: i64,
        tb_b: AVRational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the remainders of two integer operands divided by a common divisor.\n\n In other words, compare the least significant `log2(mod)` bits of integers\n `a` and `b`.\n\n @code{.c}\n av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)\n av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)\n @endcode\n\n @param a Operand\n @param b Operand\n @param mod Divisor; must be a power of 2\n @return\n         - a negative value if `a % mod < b % mod`\n         - a positive value if `a % mod > b % mod`\n         - zero             if `a % mod == b % mod`"]
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    #[doc = " Rescale a timestamp while preserving known durations.\n\n This function is designed to be called per audio packet to scale the input\n timestamp to a different time base. Compared to a simple av_rescale_q()\n call, this function is robust against possible inconsistent frame durations.\n\n The `last` parameter is a state variable that must be preserved for all\n subsequent calls for the same stream. For the first call, `*last` should be\n initialized to #AV_NOPTS_VALUE.\n\n @param[in]     in_tb    Input time base\n @param[in]     in_ts    Input timestamp\n @param[in]     fs_tb    Duration time base; typically this is finer-grained\n                         (greater) than `in_tb` and `out_tb`\n @param[in]     duration Duration till the next call to this function (i.e.\n                         duration of the current packet/frame)\n @param[in,out] last     Pointer to a timestamp expressed in terms of\n                         `fs_tb`, acting as a state variable\n @param[in]     out_tb   Output timebase\n @return        Timestamp expressed in terms of `out_tb`\n\n @note In the context of this function, \"duration\" is in term of samples, not\n       seconds."]
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: ::std::os::raw::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    #[doc = " Add a value to a timestamp.\n\n This function guarantees that when the same value is repeatly added that\n no accumulation of rounding errors occurs.\n\n @param[in] ts     Input timestamp\n @param[in] ts_tb  Input timestamp time base\n @param[in] inc    Value to be added\n @param[in] inc_tb Time base of `inc`"]
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
extern "C" {
    #[doc = " 0th order modified bessel function of the first kind."]
    pub fn av_bessel_i0(x: f64) -> f64;
}
pub type __gnuc_va_list = __builtin_va_list;
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
#[doc = "< not part of ABI/API"]
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    _unused: [u8; 0],
}
#[doc = " Describe the class of an AVClass context structure. That is an\n arbitrary struct of which the first field is a pointer to an\n AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVClass {
    #[doc = " The name of the class; usually it is the same name as the\n context structure type to which the AVClass is associated."]
    pub class_name: *const ::std::os::raw::c_char,
    #[doc = " A pointer to a function which returns the name of a context\n instance ctx associated with the class."]
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " a pointer to the first option specified in the class if any or NULL\n\n @see av_set_default_options()"]
    pub option: *mut AVOption,
    #[doc = " LIBAVUTIL_VERSION with which this structure was created.\n This is used to allow fields to be added without requiring major\n version bumps everywhere."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where log_level_offset is stored.\n 0 means there is no such variable"]
    pub log_level_offset_offset: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where a pointer to the parent context for\n logging is stored. For example a decoder could pass its AVCodecContext\n to eval as such a parent context, which an av_log() implementation\n could then leverage to display the parent context.\n The offset can be NULL."]
    pub parent_log_context_offset: ::std::os::raw::c_int,
    #[doc = " Category used for visualization (like color)\n This is only set if the category is equal for all objects using this class.\n available since version (51 << 16 | 56 << 8 | 100)"]
    pub category: AVClassCategory,
    #[doc = " Callback to return the category.\n available since version (51 << 16 | 59 << 8 | 100)"]
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    #[doc = " Callback to return the supported/allowed ranges.\n available since version (52.12)"]
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return next AVOptions-enabled child or NULL"]
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled\n children.\n\n @param iter pointer to opaque iteration state. The caller must initialize\n             *iter to NULL before the first call.\n @return AVClass for the next AVOptions-enabled child or NULL if there are\n         no more such children.\n\n @note The difference between child_next and this is that child_next\n       iterates over _already existing_ objects, while child_class_iterate\n       iterates over _all possible_ children."]
    pub child_class_iterate: ::std::option::Option<
        unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const AVClass,
    >,
}
impl Default for AVClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output."]
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log once with the initial_level and then with\n the subsequent_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param initial_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" for the first occurance.\n @param subsequent_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" after the first occurance.\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param state a variable to keep trak of if a message has already been printed\n        this must be initialized to 0 before the first use. The same state\n        must not be accessed by 2 Threads simultaneously."]
    pub fn av_log_once(
        avcl: *mut ::std::os::raw::c_void,
        initial_level: ::std::os::raw::c_int,
        subsequent_level: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    #[doc = " Get the current log level\n\n @see lavu_log_constants\n\n @return Current log level"]
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level\n\n @see lavu_log_constants\n\n @param level Logging level"]
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the logging callback\n\n @note The callback must be thread safe, even if the application does not use\n       threads itself as some codecs are multithreaded.\n\n @see av_log_default_callback\n\n @param callback A logging function with a compatible signature."]
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: va_list,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Default logging callback\n\n It prints the message to stderr, optionally colorizing it.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
    );
}
extern "C" {
    #[doc = " Return the context name\n\n @param  ctx The AVClass context\n\n @return The AVClass class_name"]
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line\n @param line_size     size of the buffer\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1"]
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line;\n                      may be NULL if line_size is 0\n @param line_size     size of the buffer; at most line_size-1 characters will\n                      be written to the buffer, plus one null terminator\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1\n @return Returns a negative value if an error occurred, otherwise returns\n         the number of characters that would have been written for a\n         sufficiently large buffer, not including the terminating null\n         character. If the return value is not less than line_size, it means\n         that the log message was truncated to fit the buffer."]
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: va_list,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
#[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
#[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
#[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
#[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
#[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
#[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
#[doc = "<        Y        ,  8bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
#[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
#[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
#[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
#[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
#[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
#[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
#[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
#[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)3R 3G 2B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
#[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
#[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
#[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
#[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
#[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
#[doc = "<        Y        , 16bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
#[doc = "<        Y        , 16bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
#[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
#[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
#[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
#[doc = "  Hardware acceleration through VA-API, data[3] contains a\n  VASurfaceID."]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 44;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 45;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 46;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 47;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 48;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 49;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 50;
#[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 51;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 52;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 53;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 54;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 55;
#[doc = "< 8 bits gray, 8 bits alpha"]
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 56;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 56;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 56;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 57;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 58;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 59;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 60;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 61;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 62;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 63;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 64;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 65;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 66;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 67;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 68;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 69;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 70;
#[doc = "< planar GBR 4:4:4 24bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 71;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 71;
#[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 72;
#[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 73;
#[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 74;
#[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 75;
#[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 76;
#[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 77;
#[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 78;
#[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 79;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 80;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 81;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 82;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 83;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 84;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 85;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 86;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 87;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 88;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 89;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 90;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 91;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 92;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 93;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 94;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 95;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 96;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 97;
#[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 98;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 99;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 100;
#[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 101;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 102;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 103;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 104;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 105;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 106;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 107;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 108;
#[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 109;
#[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 110;
#[doc = "< planar GBRA 4:4:4:4 32bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 111;
#[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 112;
#[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 113;
#[doc = " HW acceleration through QSV, data[3] contains a pointer to the\n mfxFrameSurface1 structure.\n\n Before FFmpeg 5.0:\n mfxFrameSurface1.Data.MemId contains a pointer when importing\n the following frames as QSV frames:\n\n VAAPI:\n mfxFrameSurface1.Data.MemId contains a pointer to VASurfaceID\n\n DXVA2:\n mfxFrameSurface1.Data.MemId contains a pointer to IDirect3DSurface9\n\n FFmpeg 5.0 and above:\n mfxFrameSurface1.Data.MemId contains a pointer to the mfxHDLPair\n structure when importing the following frames as QSV frames:\n\n VAAPI:\n mfxHDLPair.first contains a VASurfaceID pointer.\n mfxHDLPair.second is always MFX_INFINITE.\n\n DXVA2:\n mfxHDLPair.first contains IDirect3DSurface9 pointer.\n mfxHDLPair.second is always MFX_INFINITE.\n\n D3D11:\n mfxHDLPair.first contains a ID3D11Texture2D pointer.\n mfxHDLPair.second contains the texture array index of the frame if the\n ID3D11Texture2D is an array texture, or always MFX_INFINITE if it is a\n normal texture."]
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 114;
#[doc = " HW acceleration though MMAL, data[3] contains a pointer to the\n MMAL_BUFFER_HEADER_T structure."]
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 115;
#[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 116;
#[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers\n exactly as for system memory frames."]
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 117;
#[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 118;
#[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 119;
#[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 120;
#[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 121;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 122;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 123;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 124;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 125;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 126;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 127;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 128;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 129;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 130;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 131;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 132;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 133;
#[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 134;
#[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 135;
#[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 136;
#[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 137;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 138;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 139;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 140;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 141;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 142;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 143;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 144;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 145;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 146;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 147;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 148;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 149;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 150;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 151;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 152;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 153;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 154;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 155;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 156;
#[doc = "< hardware decoding through Videotoolbox"]
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 157;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 158;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 159;
#[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 160;
#[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 161;
#[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 162;
#[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 163;
#[doc = "< hardware decoding through MediaCodec"]
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 164;
#[doc = "<        Y        , 12bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 165;
#[doc = "<        Y        , 12bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 166;
#[doc = "<        Y        , 10bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 167;
#[doc = "<        Y        , 10bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 168;
#[doc = "< like NV12, with 16bpp per component, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 169;
#[doc = "< like NV12, with 16bpp per component, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 170;
#[doc = " Hardware surfaces for Direct3D11.\n\n This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11\n hwaccel API and filtering support AV_PIX_FMT_D3D11 only.\n\n data[0] contains a ID3D11Texture2D pointer, and data[1] contains the\n texture array index of the frame as intptr_t if the ID3D11Texture2D is\n an array texture (or always 0 if it's a normal texture)."]
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 171;
#[doc = "<        Y        , 9bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 172;
#[doc = "<        Y        , 9bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 173;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 174;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 175;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 176;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 177;
#[doc = " DRM-managed buffers exposed through PRIME buffer sharing.\n\n data[0] points to an AVDRMFrameDescriptor."]
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 178;
#[doc = " Hardware surfaces for OpenCL.\n\n data[i] contain 2D image objects (typed in C as cl_mem, used\n in OpenCL as image2d_t) for each plane of the surface."]
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 179;
#[doc = "<        Y        , 14bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: AVPixelFormat = 180;
#[doc = "<        Y        , 14bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: AVPixelFormat = 181;
#[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 182;
#[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 183;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 184;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 185;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 186;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 187;
#[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV24: AVPixelFormat = 188;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV42: AVPixelFormat = 189;
#[doc = " Vulkan hardware images.\n\n data[0] points to an AVVkFrame"]
pub const AVPixelFormat_AV_PIX_FMT_VULKAN: AVPixelFormat = 190;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210BE: AVPixelFormat = 191;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210LE: AVPixelFormat = 192;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10LE: AVPixelFormat = 193;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10BE: AVPixelFormat = 194;
#[doc = "< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2BGR10LE: AVPixelFormat = 195;
#[doc = "< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), big-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2BGR10BE: AVPixelFormat = 196;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P210BE: AVPixelFormat = 197;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P210LE: AVPixelFormat = 198;
#[doc = "< interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P410BE: AVPixelFormat = 199;
#[doc = "< interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P410LE: AVPixelFormat = 200;
#[doc = "< interleaved chroma YUV 4:2:2, 32bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P216BE: AVPixelFormat = 201;
#[doc = "< interleaved chroma YUV 4:2:2, 32bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P216LE: AVPixelFormat = 202;
#[doc = "< interleaved chroma YUV 4:4:4, 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P416BE: AVPixelFormat = 203;
#[doc = "< interleaved chroma YUV 4:4:4, 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P416LE: AVPixelFormat = 204;
#[doc = "< packed VUYA 4:4:4, 32bpp, VUYAVUYA..."]
pub const AVPixelFormat_AV_PIX_FMT_VUYA: AVPixelFormat = 205;
#[doc = "< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBAF16BE: AVPixelFormat = 206;
#[doc = "< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBAF16LE: AVPixelFormat = 207;
#[doc = "< packed VUYX 4:4:4, 32bpp, Variant of VUYA where alpha channel is left undefined"]
pub const AVPixelFormat_AV_PIX_FMT_VUYX: AVPixelFormat = 208;
#[doc = "< like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P012LE: AVPixelFormat = 209;
#[doc = "< like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P012BE: AVPixelFormat = 210;
#[doc = "< packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y212BE: AVPixelFormat = 211;
#[doc = "< packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y212LE: AVPixelFormat = 212;
#[doc = "< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), big-endian, variant of Y410 where alpha channel is left undefined"]
pub const AVPixelFormat_AV_PIX_FMT_XV30BE: AVPixelFormat = 213;
#[doc = "< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), little-endian, variant of Y410 where alpha channel is left undefined"]
pub const AVPixelFormat_AV_PIX_FMT_XV30LE: AVPixelFormat = 214;
#[doc = "< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, big-endian, variant of Y412 where alpha channel is left undefined"]
pub const AVPixelFormat_AV_PIX_FMT_XV36BE: AVPixelFormat = 215;
#[doc = "< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, little-endian, variant of Y412 where alpha channel is left undefined"]
pub const AVPixelFormat_AV_PIX_FMT_XV36LE: AVPixelFormat = 216;
#[doc = "< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBF32BE: AVPixelFormat = 217;
#[doc = "< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBF32LE: AVPixelFormat = 218;
#[doc = "< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBAF32BE: AVPixelFormat = 219;
#[doc = "< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBAF32LE: AVPixelFormat = 220;
#[doc = "< interleaved chroma YUV 4:2:2, 24bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P212BE: AVPixelFormat = 221;
#[doc = "< interleaved chroma YUV 4:2:2, 24bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P212LE: AVPixelFormat = 222;
#[doc = "< interleaved chroma YUV 4:4:4, 36bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P412BE: AVPixelFormat = 223;
#[doc = "< interleaved chroma YUV 4:4:4, 36bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P412LE: AVPixelFormat = 224;
#[doc = "< planar GBR 4:4:4:4 56bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP14BE: AVPixelFormat = 225;
#[doc = "< planar GBR 4:4:4:4 56bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP14LE: AVPixelFormat = 226;
#[doc = " Hardware surfaces for Direct3D 12.\n\n data[0] points to an AVD3D12VAFrame"]
pub const AVPixelFormat_AV_PIX_FMT_D3D12: AVPixelFormat = 227;
#[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 228;
#[doc = " Pixel format.\n\n @note\n AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA\n color is put together as:\n  (A << 24) | (R << 16) | (G << 8) | B\n This is stored as BGRA on little-endian CPU architectures and ARGB on\n big-endian CPUs.\n\n @note\n If the resolution is not a multiple of the chroma subsampling factor\n then the chroma plane resolution must be rounded up.\n\n @par\n When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized\n image data is stored in AVFrame.data[0]. The palette is transported in\n AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is\n formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is\n also endian-specific). Note also that the individual RGB32 palette\n components stored in AVFrame.data[1] should be in the range 0..255.\n This is important as many custom PAL8 video codecs that were designed\n to run on the IBM VGA graphics adapter use 6-bit palette components.\n\n @par\n For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like\n for pal8. This palette is filled in automatically by the function\n allocating the picture."]
pub type AVPixelFormat = ::std::os::raw::c_int;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B"]
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
#[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
#[doc = "< identical to above, also called \"SMPTE C\" even though it uses D65"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
#[doc = "< colour filters using Illuminant C"]
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
#[doc = "< ITU-R BT2020"]
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
#[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
#[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
#[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
#[doc = "< EBU Tech. 3213-E (nothing there) / one of JEDEC P22 group phosphors"]
pub const AVColorPrimaries_AVCOL_PRI_EBU3213: AVColorPrimaries = 22;
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
#[doc = "< Not part of ABI"]
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
#[doc = " Chromaticity coordinates of the source primaries.\n These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273."]
pub type AVColorPrimaries = ::std::os::raw::c_uint;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
#[doc = "< also ITU-R BT1361"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
#[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
#[doc = "< also ITU-R BT470BG"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
#[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
#[doc = "< \"Linear transfer characteristics\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
#[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
#[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
#[doc = "< IEC 61966-2-4"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
#[doc = "< ITU-R BT1361 Extended Colour Gamut"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
#[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
#[doc = "< ITU-R BT2020 for 10-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
#[doc = "< ITU-R BT2020 for 12-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
#[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
#[doc = "< SMPTE ST 428-1"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
#[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
#[doc = "< Not part of ABI"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
#[doc = " Color Transfer Characteristic.\n These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2."]
pub type AVColorTransferCharacteristic = ::std::os::raw::c_uint;
#[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB), YZX and ST 428-1"]
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / derived in SMPTE RP 177 Annex B"]
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
#[doc = "< reserved for future use by ITU-T and ISO/IEC just like 15-255 are"]
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
#[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above"]
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
#[doc = "< derived from 170M primaries and D65 white point, 170M is derived from BT470 System M's primaries"]
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
#[doc = "< used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
#[doc = "< ITU-R BT2020 non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
#[doc = "< ITU-R BT2020 constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
#[doc = "< SMPTE 2085, Y'D'zD'x"]
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
#[doc = "< Chromaticity-derived non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
#[doc = "< Chromaticity-derived constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
#[doc = "< ITU-R BT.2100-0, ICtCp"]
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
#[doc = "< SMPTE ST 2128, IPT-C2"]
pub const AVColorSpace_AVCOL_SPC_IPT_C2: AVColorSpace = 15;
#[doc = "< YCgCo-R, even addition of bits"]
pub const AVColorSpace_AVCOL_SPC_YCGCO_RE: AVColorSpace = 16;
#[doc = "< YCgCo-R, odd addition of bits"]
pub const AVColorSpace_AVCOL_SPC_YCGCO_RO: AVColorSpace = 17;
#[doc = "< Not part of ABI"]
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 18;
#[doc = " YUV colorspace type.\n These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3."]
pub type AVColorSpace = ::std::os::raw::c_uint;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
#[doc = " Narrow or limited range content.\n\n - For luma planes:\n\n       (219 * E + 16) * 2^(n-8)\n\n   F.ex. the range of 16-235 for 8 bits\n\n - For chroma planes:\n\n       (224 * E + 128) * 2^(n-8)\n\n   F.ex. the range of 16-240 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
#[doc = " Full range content.\n\n - For RGB and luma planes:\n\n       (2^n - 1) * E\n\n   F.ex. the range of 0-255 for 8 bits\n\n - For chroma planes:\n\n       (2^n - 1) * E + 2^(n - 1)\n\n   F.ex. the range of 1-255 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
#[doc = "< Not part of ABI"]
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
#[doc = " Visual content value range.\n\n These values are based on definitions that can be found in multiple\n specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance\n and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital\n Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit\n integer representation). At the time of writing, the BT.2100 one is\n recommended, as it also defines the full range representation.\n\n Common definitions:\n   - For RGB and luma planes such as Y in YCbCr and I in ICtCp,\n     'E' is the original value in range of 0.0 to 1.0.\n   - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original\n     value in range of -0.5 to 0.5.\n   - 'n' is the output bit depth.\n   - For additional definitions such as rounding and clipping to valid n\n     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
pub type AVColorRange = ::std::os::raw::c_uint;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
#[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
#[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
#[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
#[doc = "< Not part of ABI"]
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
#[doc = " Location of chroma samples.\n\n Illustration showing the location of the first (top left) chroma sample of the\n image, the left shows only luma, the right\n shows the location of the chroma sample, the 2 could be imagined to overlay\n each other but are drawn separately due to limitations of ASCII\n\n                1st 2nd       1st 2nd horizontal luma sample positions\n                 v   v         v   v\n                 ______        ______\n1st luma line > |X   X ...    |3 4 X ...     X are luma samples,\n                |             |1 2           1-6 are possible chroma positions\n2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
pub type AVChromaLocation = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Compute the length of an integer list.\n\n @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)\n @param term    list terminator (usually 0 or -1)\n @param list    pointer to the list\n @return  length of the list, in elements, not counting the terminator"]
    pub fn av_int_list_length_for_size(
        elsize: ::std::os::raw::c_uint,
        list: *const ::std::os::raw::c_void,
        term: u64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the fractional representation of the internal time base."]
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    #[doc = " Fill the provided buffer with a string containing a FourCC (four-character\n code) representation.\n\n @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE\n @param fourcc the fourcc to represent\n @return the buffer in input"]
    pub fn av_fourcc_make_string(
        buf: *mut ::std::os::raw::c_char,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[doc = " A reference to a data buffer.\n\n The size of this struct is not a part of the public ABI and it is not meant\n to be allocated directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    #[doc = " The data buffer. It is considered writable if and only if\n this is the only reference to the buffer, in which case\n av_buffer_is_writable() returns 1."]
    pub data: *mut u8,
    #[doc = " Size of data in bytes."]
    pub size: usize,
}
impl Default for AVBufferRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Allocate an AVBuffer of the given size using av_malloc().\n\n @return an AVBufferRef of given size or NULL when out of memory"]
    pub fn av_buffer_alloc(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Same as av_buffer_alloc(), except the returned buffer will be initialized\n to zero."]
    pub fn av_buffer_allocz(size: usize) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Create an AVBuffer from an existing array.\n\n If this function is successful, data is owned by the AVBuffer. The caller may\n only access data through the returned AVBufferRef and references derived from\n it.\n If this function fails, data is left untouched.\n @param data   data array\n @param size   size of data in bytes\n @param free   a callback for freeing this buffer's data\n @param opaque parameter to be got for processing or passed to free\n @param flags  a combination of AV_BUFFER_FLAG_*\n\n @return an AVBufferRef referring to data on success, NULL on failure."]
    pub fn av_buffer_create(
        data: *mut u8,
        size: usize,
        free: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
        >,
        opaque: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Default free callback, which calls av_free() on the buffer data.\n This function is meant to be passed to av_buffer_create(), not called\n directly."]
    pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
    #[doc = " Create a new reference to an AVBuffer.\n\n @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on\n failure."]
    pub fn av_buffer_ref(buf: *const AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Free a given reference and automatically free the buffer if there are no more\n references to it.\n\n @param buf the reference to be freed. The pointer is set to NULL on return."]
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    #[doc = " @return 1 if the caller may write to the data referred to by buf (which is\n true if and only if buf is the only reference to the underlying AVBuffer).\n Return 0 otherwise.\n A positive answer is valid until av_buffer_ref() is called on buf."]
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the opaque parameter set by av_buffer_create."]
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a writable reference from a given buffer reference, avoiding data copy\n if possible.\n\n @param buf buffer reference to make writable. On success, buf is either left\n            untouched, or it is unreferenced and a new writable AVBufferRef is\n            written in its place. On failure, buf is left untouched.\n @return 0 on success, a negative AVERROR on failure."]
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reallocate a given buffer.\n\n @param buf  a buffer reference to reallocate. On success, buf will be\n             unreferenced and a new reference with the required size will be\n             written in its place. On failure buf will be left untouched. *buf\n             may be NULL, then a new buffer is allocated.\n @param size required new buffer size.\n @return 0 on success, a negative AVERROR on failure.\n\n @note the buffer is actually reallocated with av_realloc() only if it was\n initially allocated through av_buffer_realloc(NULL) and there is only one\n reference to it (i.e. the one passed to this function). In all other cases\n a new buffer is allocated and the data is copied."]
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure dst refers to the same data as src.\n\n When *dst is already equivalent to src, do nothing. Otherwise unreference dst\n and replace it with a new reference to src.\n\n @param dst Pointer to either a valid buffer reference or NULL. On success,\n            this will point to a buffer reference equivalent to src. On\n            failure, dst will be left untouched.\n @param src A buffer reference to replace dst with. May be NULL, then this\n            function is equivalent to av_buffer_unref(dst).\n @return 0 on success\n         AVERROR(ENOMEM) on memory allocation failure."]
    pub fn av_buffer_replace(
        dst: *mut *mut AVBufferRef,
        src: *const AVBufferRef,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize a buffer pool.\n\n @param size size of each buffer in this pool\n @param alloc a function that will be used to allocate new buffers when the\n pool is empty. May be NULL, then the default allocator will be used\n (av_buffer_alloc()).\n @return newly created buffer pool on success, NULL on error."]
    pub fn av_buffer_pool_init(
        size: usize,
        alloc: ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut AVBufferRef>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Allocate and initialize a buffer pool with a more complex allocator.\n\n @param size size of each buffer in this pool\n @param opaque arbitrary user data used by the allocator\n @param alloc a function that will be used to allocate new buffers when the\n              pool is empty. May be NULL, then the default allocator will be\n              used (av_buffer_alloc()).\n @param pool_free a function that will be called immediately before the pool\n                  is freed. I.e. after av_buffer_pool_uninit() is called\n                  by the caller and all the frames are returned to the pool\n                  and freed. It is intended to uninitialize the user opaque\n                  data. May be NULL.\n @return newly created buffer pool on success, NULL on error."]
    pub fn av_buffer_pool_init2(
        size: usize,
        opaque: *mut ::std::os::raw::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(
                opaque: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    #[doc = " Mark the pool as being available for freeing. It will actually be freed only\n once all the allocated buffers associated with the pool are released. Thus it\n is safe to call this function while some of the allocated buffers are still\n in use.\n\n @param pool pointer to the pool to be freed. It will be set to NULL."]
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    #[doc = " Allocate a new AVBuffer, reusing an old buffer from the pool when available.\n This function may be called simultaneously from multiple threads.\n\n @return a reference to the new buffer on success, NULL on error."]
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Query the original opaque parameter of an allocated buffer in the pool.\n\n @param ref a buffer reference to a buffer returned by av_buffer_pool_get.\n @return the opaque parameter set by the buffer allocator function of the\n         buffer pool.\n\n @note the opaque parameter of ref is used by the buffer pool implementation,\n therefore you have to use this function to access the original opaque\n parameter of an allocated buffer."]
    pub fn av_buffer_pool_buffer_get_opaque(
        ref_: *const AVBufferRef,
    ) -> *mut ::std::os::raw::c_void;
}
pub const AVChannel_AV_CHAN_NONE: AVChannel = -1;
pub const AVChannel_AV_CHAN_FRONT_LEFT: AVChannel = 0;
pub const AVChannel_AV_CHAN_FRONT_RIGHT: AVChannel = 1;
pub const AVChannel_AV_CHAN_FRONT_CENTER: AVChannel = 2;
pub const AVChannel_AV_CHAN_LOW_FREQUENCY: AVChannel = 3;
pub const AVChannel_AV_CHAN_BACK_LEFT: AVChannel = 4;
pub const AVChannel_AV_CHAN_BACK_RIGHT: AVChannel = 5;
pub const AVChannel_AV_CHAN_FRONT_LEFT_OF_CENTER: AVChannel = 6;
pub const AVChannel_AV_CHAN_FRONT_RIGHT_OF_CENTER: AVChannel = 7;
pub const AVChannel_AV_CHAN_BACK_CENTER: AVChannel = 8;
pub const AVChannel_AV_CHAN_SIDE_LEFT: AVChannel = 9;
pub const AVChannel_AV_CHAN_SIDE_RIGHT: AVChannel = 10;
pub const AVChannel_AV_CHAN_TOP_CENTER: AVChannel = 11;
pub const AVChannel_AV_CHAN_TOP_FRONT_LEFT: AVChannel = 12;
pub const AVChannel_AV_CHAN_TOP_FRONT_CENTER: AVChannel = 13;
pub const AVChannel_AV_CHAN_TOP_FRONT_RIGHT: AVChannel = 14;
pub const AVChannel_AV_CHAN_TOP_BACK_LEFT: AVChannel = 15;
pub const AVChannel_AV_CHAN_TOP_BACK_CENTER: AVChannel = 16;
pub const AVChannel_AV_CHAN_TOP_BACK_RIGHT: AVChannel = 17;
#[doc = " Stereo downmix."]
pub const AVChannel_AV_CHAN_STEREO_LEFT: AVChannel = 29;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_STEREO_RIGHT: AVChannel = 30;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_WIDE_LEFT: AVChannel = 31;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_WIDE_RIGHT: AVChannel = 32;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_SURROUND_DIRECT_LEFT: AVChannel = 33;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_SURROUND_DIRECT_RIGHT: AVChannel = 34;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_LOW_FREQUENCY_2: AVChannel = 35;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_TOP_SIDE_LEFT: AVChannel = 36;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_TOP_SIDE_RIGHT: AVChannel = 37;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_BOTTOM_FRONT_CENTER: AVChannel = 38;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_BOTTOM_FRONT_LEFT: AVChannel = 39;
#[doc = " See above."]
pub const AVChannel_AV_CHAN_BOTTOM_FRONT_RIGHT: AVChannel = 40;
#[doc = " Channel is empty can be safely skipped."]
pub const AVChannel_AV_CHAN_UNUSED: AVChannel = 512;
#[doc = " Channel contains data, but its position is unknown."]
pub const AVChannel_AV_CHAN_UNKNOWN: AVChannel = 768;
#[doc = " Range of channels between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.\n\n Given a channel id `<i>` between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel `<n>` is\n `<n> = <i> - AV_CHAN_AMBISONIC_BASE`.\n\n @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel\n orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels\n implicitly by their position in the stream."]
pub const AVChannel_AV_CHAN_AMBISONIC_BASE: AVChannel = 1024;
#[doc = " Range of channels between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.\n\n Given a channel id `<i>` between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel `<n>` is\n `<n> = <i> - AV_CHAN_AMBISONIC_BASE`.\n\n @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel\n orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels\n implicitly by their position in the stream."]
pub const AVChannel_AV_CHAN_AMBISONIC_END: AVChannel = 2047;
#[doc = " @defgroup lavu_audio_channels Audio channels\n @ingroup lavu_audio\n\n Audio channel layout utility functions\n\n @{"]
pub type AVChannel = ::std::os::raw::c_int;
#[doc = " Only the channel count is specified, without any further information\n about the channel order."]
pub const AVChannelOrder_AV_CHANNEL_ORDER_UNSPEC: AVChannelOrder = 0;
#[doc = " The native channel order, i.e. the channels are in the same order in\n which they are defined in the AVChannel enum. This supports up to 63\n different channels."]
pub const AVChannelOrder_AV_CHANNEL_ORDER_NATIVE: AVChannelOrder = 1;
#[doc = " The channel order does not correspond to any other predefined order and\n is stored as an explicit map. For example, this could be used to support\n layouts with 64 or more channels, or with empty/skipped (AV_CHAN_UNUSED)\n channels at arbitrary positions."]
pub const AVChannelOrder_AV_CHANNEL_ORDER_CUSTOM: AVChannelOrder = 2;
#[doc = " The audio is represented as the decomposition of the sound field into\n spherical harmonics. Each channel corresponds to a single expansion\n component. Channels are ordered according to ACN (Ambisonic Channel\n Number).\n\n The channel with the index n in the stream contains the spherical\n harmonic of degree l and order m given by\n @code{.unparsed}\n   l   = floor(sqrt(n)),\n   m   = n - l * (l + 1).\n @endcode\n\n Conversely given a spherical harmonic of degree l and order m, the\n corresponding channel index n is given by\n @code{.unparsed}\n   n = l * (l + 1) + m.\n @endcode\n\n Normalization is assumed to be SN3D (Schmidt Semi-Normalization)\n as defined in AmbiX format $ 2.1."]
pub const AVChannelOrder_AV_CHANNEL_ORDER_AMBISONIC: AVChannelOrder = 3;
#[doc = " Number of channel orders, not part of ABI/API"]
pub const AVChannelOrder_FF_CHANNEL_ORDER_NB: AVChannelOrder = 4;
pub type AVChannelOrder = ::std::os::raw::c_uint;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NONE: AVMatrixEncoding = 0;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBY: AVMatrixEncoding = 1;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLII: AVMatrixEncoding = 2;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIX: AVMatrixEncoding = 3;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIZ: AVMatrixEncoding = 4;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYEX: AVMatrixEncoding = 5;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYHEADPHONE: AVMatrixEncoding = 6;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NB: AVMatrixEncoding = 7;
pub type AVMatrixEncoding = ::std::os::raw::c_uint;
#[doc = " An AVChannelCustom defines a single channel within a custom order layout\n\n Unlike most structures in FFmpeg, sizeof(AVChannelCustom) is a part of the\n public ABI.\n\n No new fields may be added to it without a major version bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVChannelCustom {
    pub id: AVChannel,
    pub name: [::std::os::raw::c_char; 16usize],
    pub opaque: *mut ::std::os::raw::c_void,
}
impl Default for AVChannelCustom {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An AVChannelLayout holds information about the channel layout of audio data.\n\n A channel layout here is defined as a set of channels ordered in a specific\n way (unless the channel order is AV_CHANNEL_ORDER_UNSPEC, in which case an\n AVChannelLayout carries only the channel count).\n All orders may be treated as if they were AV_CHANNEL_ORDER_UNSPEC by\n ignoring everything but the channel count, as long as av_channel_layout_check()\n considers they are valid.\n\n Unlike most structures in FFmpeg, sizeof(AVChannelLayout) is a part of the\n public ABI and may be used by the caller. E.g. it may be allocated on stack\n or embedded in caller-defined structs.\n\n AVChannelLayout can be initialized as follows:\n - default initialization with {0}, followed by setting all used fields\n   correctly;\n - by assigning one of the predefined AV_CHANNEL_LAYOUT_* initializers;\n - with a constructor function, such as av_channel_layout_default(),\n   av_channel_layout_from_mask() or av_channel_layout_from_string().\n\n The channel layout must be unitialized with av_channel_layout_uninit()\n\n Copying an AVChannelLayout via assigning is forbidden,\n av_channel_layout_copy() must be used instead (and its return value should\n be checked)\n\n No new fields may be added to it without a major version bump, except for\n new elements of the union fitting in sizeof(uint64_t)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVChannelLayout {
    #[doc = " Channel order used in this layout.\n This is a mandatory field."]
    pub order: AVChannelOrder,
    #[doc = " Number of channels in this layout. Mandatory field."]
    pub nb_channels: ::std::os::raw::c_int,
    pub u: AVChannelLayout__bindgen_ty_1,
    #[doc = " For some private data of the user."]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[doc = " Details about which channels are present in this layout.\n For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be\n used."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVChannelLayout__bindgen_ty_1 {
    #[doc = " This member must be used for AV_CHANNEL_ORDER_NATIVE, and may be used\n for AV_CHANNEL_ORDER_AMBISONIC to signal non-diegetic channels.\n It is a bitmask, where the position of each set bit means that the\n AVChannel with the corresponding value is present.\n\n I.e. when (mask & (1 << AV_CHAN_FOO)) is non-zero, then AV_CHAN_FOO\n is present in the layout. Otherwise it is not present.\n\n @note when a channel layout using a bitmask is constructed or\n modified manually (i.e.  not using any of the av_channel_layout_*\n functions), the code doing it must ensure that the number of set bits\n is equal to nb_channels."]
    pub mask: u64,
    #[doc = " This member must be used when the channel order is\n AV_CHANNEL_ORDER_CUSTOM. It is a nb_channels-sized array, with each\n element signalling the presence of the AVChannel with the\n corresponding value in map[i].id.\n\n I.e. when map[i].id is equal to AV_CHAN_FOO, then AV_CH_FOO is the\n i-th channel in the audio data.\n\n When map[i].id is in the range between AV_CHAN_AMBISONIC_BASE and\n AV_CHAN_AMBISONIC_END (inclusive), the channel contains an ambisonic\n component with ACN index (as defined above)\n n = map[i].id - AV_CHAN_AMBISONIC_BASE.\n\n map[i].name may be filled with a 0-terminated string, in which case\n it will be used for the purpose of identifying the channel with the\n convenience functions below. Otherise it must be zeroed."]
    pub map: *mut AVChannelCustom,
}
impl Default for AVChannelLayout__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for AVChannelLayout {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a human readable string in an abbreviated form describing a given channel.\n This is the inverse function of @ref av_channel_from_string().\n\n @param buf pre-allocated buffer where to put the generated string\n @param buf_size size in bytes of the buffer.\n @param channel the AVChannel whose name to get\n @return amount of bytes needed to hold the output string, or a negative AVERROR\n         on failure. If the returned value is bigger than buf_size, then the\n         string was truncated."]
    pub fn av_channel_name(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bprint variant of av_channel_name().\n\n @note the string will be appended to the bprint buffer."]
    pub fn av_channel_name_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    #[doc = " Get a human readable string describing a given channel.\n\n @param buf pre-allocated buffer where to put the generated string\n @param buf_size size in bytes of the buffer.\n @param channel the AVChannel whose description to get\n @return amount of bytes needed to hold the output string, or a negative AVERROR\n         on failure. If the returned value is bigger than buf_size, then the\n         string was truncated."]
    pub fn av_channel_description(
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bprint variant of av_channel_description().\n\n @note the string will be appended to the bprint buffer."]
    pub fn av_channel_description_bprint(bp: *mut AVBPrint, channel_id: AVChannel);
}
extern "C" {
    #[doc = " This is the inverse function of @ref av_channel_name().\n\n @return the channel with the given name\n         AV_CHAN_NONE when name does not identify a known channel"]
    pub fn av_channel_from_string(name: *const ::std::os::raw::c_char) -> AVChannel;
}
extern "C" {
    #[doc = " Initialize a custom channel layout with the specified number of channels.\n The channel map will be allocated and the designation of all channels will\n be set to AV_CHAN_UNKNOWN.\n\n This is only a convenience helper function, a custom channel layout can also\n be constructed without using this.\n\n @param channel_layout the layout structure to be initialized\n @param nb_channels the number of channels\n\n @return 0 on success\n         AVERROR(EINVAL) if the number of channels <= 0\n         AVERROR(ENOMEM) if the channel map could not be allocated"]
    pub fn av_channel_layout_custom_init(
        channel_layout: *mut AVChannelLayout,
        nb_channels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a native channel layout from a bitmask indicating which channels\n are present.\n\n @param channel_layout the layout structure to be initialized\n @param mask bitmask describing the channel layout\n\n @return 0 on success\n         AVERROR(EINVAL) for invalid mask values"]
    pub fn av_channel_layout_from_mask(
        channel_layout: *mut AVChannelLayout,
        mask: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a channel layout from a given string description.\n The input string can be represented by:\n  - the formal channel layout name (returned by av_channel_layout_describe())\n  - single or multiple channel names (returned by av_channel_name(), eg. \"FL\",\n    or concatenated with \"+\", each optionally containing a custom name after\n    a \"@\", eg. \"FL@Left+FR@Right+LFE\")\n  - a decimal or hexadecimal value of a native channel layout (eg. \"4\" or \"0x4\")\n  - the number of channels with default layout (eg. \"4c\")\n  - the number of unordered channels (eg. \"4C\" or \"4 channels\")\n  - the ambisonic order followed by optional non-diegetic channels (eg.\n    \"ambisonic 2+stereo\")\n On error, the channel layout will remain uninitialized, but not necessarily\n untouched.\n\n @param channel_layout uninitialized channel layout for the result\n @param str string describing the channel layout\n @return 0 on success parsing the channel layout\n         AVERROR(EINVAL) if an invalid channel layout string was provided\n         AVERROR(ENOMEM) if there was not enough memory"]
    pub fn av_channel_layout_from_string(
        channel_layout: *mut AVChannelLayout,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default channel layout for a given number of channels.\n\n @param ch_layout the layout structure to be initialized\n @param nb_channels number of channels"]
    pub fn av_channel_layout_default(
        ch_layout: *mut AVChannelLayout,
        nb_channels: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Iterate over all standard channel layouts.\n\n @param opaque a pointer where libavutil will store the iteration state. Must\n               point to NULL to start the iteration.\n\n @return the standard channel layout or NULL when the iteration is\n         finished"]
    pub fn av_channel_layout_standard(
        opaque: *mut *mut ::std::os::raw::c_void,
    ) -> *const AVChannelLayout;
}
extern "C" {
    #[doc = " Free any allocated data in the channel layout and reset the channel\n count to 0.\n\n @param channel_layout the layout structure to be uninitialized"]
    pub fn av_channel_layout_uninit(channel_layout: *mut AVChannelLayout);
}
extern "C" {
    #[doc = " Make a copy of a channel layout. This differs from just assigning src to dst\n in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.\n\n @note the destination channel_layout will be always uninitialized before copy.\n\n @param dst destination channel layout\n @param src source channel layout\n @return 0 on success, a negative AVERROR on error."]
    pub fn av_channel_layout_copy(
        dst: *mut AVChannelLayout,
        src: *const AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a human-readable string describing the channel layout properties.\n The string will be in the same format that is accepted by\n @ref av_channel_layout_from_string(), allowing to rebuild the same\n channel layout, except for opaque pointers.\n\n @param channel_layout channel layout to be described\n @param buf pre-allocated buffer where to put the generated string\n @param buf_size size in bytes of the buffer.\n @return amount of bytes needed to hold the output string, or a negative AVERROR\n         on failure. If the returned value is bigger than buf_size, then the\n         string was truncated."]
    pub fn av_channel_layout_describe(
        channel_layout: *const AVChannelLayout,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " bprint variant of av_channel_layout_describe().\n\n @note the string will be appended to the bprint buffer.\n @return 0 on success, or a negative AVERROR value on failure."]
    pub fn av_channel_layout_describe_bprint(
        channel_layout: *const AVChannelLayout,
        bp: *mut AVBPrint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel with the given index in a channel layout.\n\n @param channel_layout input channel layout\n @param idx index of the channel\n @return channel with the index idx in channel_layout on success or\n         AV_CHAN_NONE on failure (if idx is not valid or the channel order is\n         unspecified)"]
    pub fn av_channel_layout_channel_from_index(
        channel_layout: *const AVChannelLayout,
        idx: ::std::os::raw::c_uint,
    ) -> AVChannel;
}
extern "C" {
    #[doc = " Get the index of a given channel in a channel layout. In case multiple\n channels are found, only the first match will be returned.\n\n @param channel_layout input channel layout\n @param channel the channel whose index to obtain\n @return index of channel in channel_layout on success or a negative number if\n         channel is not present in channel_layout."]
    pub fn av_channel_layout_index_from_channel(
        channel_layout: *const AVChannelLayout,
        channel: AVChannel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the index in a channel layout of a channel described by the given string.\n In case multiple channels are found, only the first match will be returned.\n\n This function accepts channel names in the same format as\n @ref av_channel_from_string().\n\n @param channel_layout input channel layout\n @param name string describing the channel whose index to obtain\n @return a channel index described by the given string, or a negative AVERROR\n         value."]
    pub fn av_channel_layout_index_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a channel described by the given string.\n\n This function accepts channel names in the same format as\n @ref av_channel_from_string().\n\n @param channel_layout input channel layout\n @param name string describing the channel to obtain\n @return a channel described by the given string in channel_layout on success\n         or AV_CHAN_NONE on failure (if the string is not valid or the channel\n         order is unspecified)"]
    pub fn av_channel_layout_channel_from_string(
        channel_layout: *const AVChannelLayout,
        name: *const ::std::os::raw::c_char,
    ) -> AVChannel;
}
extern "C" {
    #[doc = " Find out what channels from a given set are present in a channel layout,\n without regard for their positions.\n\n @param channel_layout input channel layout\n @param mask a combination of AV_CH_* representing a set of channels\n @return a bitfield representing all the channels from mask that are present\n         in channel_layout"]
    pub fn av_channel_layout_subset(channel_layout: *const AVChannelLayout, mask: u64) -> u64;
}
extern "C" {
    #[doc = " Check whether a channel layout is valid, i.e. can possibly describe audio\n data.\n\n @param channel_layout input channel layout\n @return 1 if channel_layout is valid, 0 otherwise."]
    pub fn av_channel_layout_check(channel_layout: *const AVChannelLayout)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether two channel layouts are semantically the same, i.e. the same\n channels are present on the same positions in both.\n\n If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is\n not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC,\n they are considered equal iff the channel counts are the same in both.\n\n @param chl input channel layout\n @param chl1 input channel layout\n @return 0 if chl and chl1 are equal, 1 if they are not equal. A negative\n         AVERROR code if one or both are invalid."]
    pub fn av_channel_layout_compare(
        chl: *const AVChannelLayout,
        chl1: *const AVChannelLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the AVChannelOrder of a channel layout.\n\n Change of AVChannelOrder can be either lossless or lossy. In case of a\n lossless conversion all the channel designations and the associated channel\n names (if any) are kept. On a lossy conversion the channel names and channel\n designations might be lost depending on the capabilities of the desired\n AVChannelOrder. Note that some conversions are simply not possible in which\n case this function returns AVERROR(ENOSYS).\n\n The following conversions are supported:\n\n Any       -> Custom     : Always possible, always lossless.\n Any       -> Unspecified: Always possible, lossless if channel designations\n   are all unknown and channel names are not used, lossy otherwise.\n Custom    -> Ambisonic  : Possible if it contains ambisonic channels with\n   optional non-diegetic channels in the end. Lossy if the channels have\n   custom names, lossless otherwise.\n Custom    -> Native     : Possible if it contains native channels in native\n     order. Lossy if the channels have custom names, lossless otherwise.\n\n On error this function keeps the original channel layout untouched.\n\n @param channel_layout channel layout which will be changed\n @param order the desired channel layout order\n @param flags a combination of AV_CHANNEL_LAYOUT_RETYPE_FLAG_* constants\n @return 0 if the conversion was successful and lossless or if the channel\n           layout was already in the desired order\n         >0 if the conversion was successful but lossy\n         AVERROR(ENOSYS) if the conversion was not possible (or would be\n           lossy and AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS was specified)\n         AVERROR(EINVAL), AVERROR(ENOMEM) on error"]
    pub fn av_channel_layout_retype(
        channel_layout: *mut AVChannelLayout,
        order: AVChannelOrder,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVDictionaryEntry {
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
impl Default for AVDictionaryEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a dictionary entry with matching key.\n\n The returned entry key or value must not be changed, or it will\n cause undefined behavior.\n\n @param prev  Set to the previous matching element to find the next.\n              If set to NULL the first matching element is returned.\n @param key   Matching key\n @param flags A collection of AV_DICT_* flags controlling how the\n              entry is retrieved\n\n @return      Found entry or NULL in case no matching entry was found in the dictionary"]
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const ::std::os::raw::c_char,
        prev: *const AVDictionaryEntry,
        flags: ::std::os::raw::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    #[doc = " Iterate over a dictionary\n\n Iterates through all entries in the dictionary.\n\n @warning The returned AVDictionaryEntry key/value must not be changed.\n\n @warning As av_dict_set() invalidates all previous entries returned\n by this function, it must not be called while iterating over the dict.\n\n Typical usage:\n @code\n const AVDictionaryEntry *e = NULL;\n while ((e = av_dict_iterate(m, e))) {\n     // ...\n }\n @endcode\n\n @param m     The dictionary to iterate over\n @param prev  Pointer to the previous AVDictionaryEntry, NULL initially\n\n @retval AVDictionaryEntry* The next element in the dictionary\n @retval NULL               No more elements in the dictionary"]
    pub fn av_dict_iterate(
        m: *const AVDictionary,
        prev: *const AVDictionaryEntry,
    ) -> *const AVDictionaryEntry;
}
extern "C" {
    #[doc = " Get number of entries in dictionary.\n\n @param m dictionary\n @return  number of entries in dictionary"]
    pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the given entry in *pm, overwriting an existing entry.\n\n Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,\n these arguments will be freed on error.\n\n @warning Adding a new entry to a dictionary invalidates all existing entries\n previously returned with av_dict_get() or av_dict_iterate().\n\n @param pm        Pointer to a pointer to a dictionary struct. If *pm is NULL\n                  a dictionary struct is allocated and put in *pm.\n @param key       Entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)\n @param value     Entry value to add to *pm (will be av_strduped or added as a new key depending on flags).\n                  Passing a NULL value will cause an existing entry to be deleted.\n\n @return          >= 0 on success otherwise an error code <0"]
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience wrapper for av_dict_set() that converts the value to a string\n and stores it.\n\n Note: If ::AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error."]
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const ::std::os::raw::c_char,
        value: i64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse the key/value pairs list and add the parsed entries to a dictionary.\n\n In case of failure, all the successfully set entries are stored in\n *pm. You may need to manually free the created dictionary.\n\n @param key_val_sep  A 0-terminated list of characters used to separate\n                     key from value\n @param pairs_sep    A 0-terminated list of characters used to separate\n                     two pairs from each other\n @param flags        Flags to use when adding to the dictionary.\n                     ::AV_DICT_DONT_STRDUP_KEY and ::AV_DICT_DONT_STRDUP_VAL\n                     are ignored since the key/value tokens will always\n                     be duplicated.\n\n @return             0 on success, negative AVERROR code on failure"]
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str_: *const ::std::os::raw::c_char,
        key_val_sep: *const ::std::os::raw::c_char,
        pairs_sep: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy entries from one AVDictionary struct into another.\n\n @note Metadata is read using the ::AV_DICT_IGNORE_SUFFIX flag\n\n @param dst   Pointer to a pointer to a AVDictionary struct to copy into. If *dst is NULL,\n              this function will allocate a struct for you and put it in *dst\n @param src   Pointer to the source AVDictionary struct to copy items from.\n @param flags Flags to use when setting entries in *dst\n\n @return 0 on success, negative AVERROR code on failure. If dst was allocated\n           by this function, callers should free the associated memory."]
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free all the memory allocated for an AVDictionary struct\n and all keys and values."]
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    #[doc = " Get dictionary entries as a string.\n\n Create a string containing dictionary's entries.\n Such string may be passed back to av_dict_parse_string().\n @note String is escaped with backslashes ('\\').\n\n @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same.\n\n @param[in]  m             The dictionary\n @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.\n                           Buffer must be freed by the caller when is no longer needed.\n @param[in]  key_val_sep   Character used to separate key from value\n @param[in]  pairs_sep     Character used to separate two pairs from each other\n\n @return                   >= 0 on success, negative on error"]
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut ::std::os::raw::c_char,
        key_val_sep: ::std::os::raw::c_char,
        pairs_sep: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
#[doc = "< unsigned 8 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
#[doc = "< signed 16 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
#[doc = "< signed 32 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
#[doc = "< float"]
pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
#[doc = "< double"]
pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
#[doc = "< unsigned 8 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
#[doc = "< signed 16 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
#[doc = "< signed 32 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
#[doc = "< float, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
#[doc = "< double, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
#[doc = "< signed 64 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
#[doc = "< signed 64 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
#[doc = "< Number of sample formats. DO NOT USE if linking dynamically"]
pub const AVSampleFormat_AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
#[doc = " Audio sample formats\n\n - The data described by the sample format is always in native-endian order.\n   Sample values can be expressed by native C types, hence the lack of a signed\n   24-bit sample format even though it is a common raw audio data format.\n\n - The floating-point formats are based on full volume being in the range\n   [-1.0, 1.0]. Any values outside this range are beyond full volume level.\n\n - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg\n   (such as AVFrame in libavcodec) is as follows:\n\n @par\n For planar sample formats, each audio channel is in a separate data plane,\n and linesize is the buffer size, in bytes, for a single plane. All data\n planes must be the same size. For packed sample formats, only the first data\n plane is used, and samples for each channel are interleaved. In this case,\n linesize is the buffer size, in bytes, for the 1 plane.\n"]
pub type AVSampleFormat = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Return the name of sample_fmt, or NULL if sample_fmt is not\n recognized."]
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE\n on error."]
    pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Return the planar<->packed alternative form of the given sample format, or\n AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the\n requested planar/packed format, the format returned is the same as the\n input."]
    pub fn av_get_alt_sample_fmt(
        sample_fmt: AVSampleFormat,
        planar: ::std::os::raw::c_int,
    ) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the packed alternative form of the given sample format.\n\n If the passed sample_fmt is already in packed format, the format returned is\n the same as the input.\n\n @return  the packed alternative form of the given sample format or\nAV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Get the planar alternative form of the given sample format.\n\n If the passed sample_fmt is already in planar format, the format returned is\n the same as the input.\n\n @return  the planar alternative form of the given sample format or\nAV_SAMPLE_FMT_NONE on error."]
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    #[doc = " Generate a string corresponding to the sample format with\n sample_fmt, or a header if sample_fmt is negative.\n\n @param buf the buffer where to write the string\n @param buf_size the size of buf\n @param sample_fmt the number of the sample format to print the\n corresponding info string, or a negative value to print the\n corresponding header.\n @return the pointer to the filled buffer or NULL if sample_fmt is\n unknown or in case of other errors"]
    pub fn av_get_sample_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return number of bytes per sample.\n\n @param sample_fmt the sample format\n @return number of bytes per sample or zero if unknown for the given\n sample format"]
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the sample format is planar.\n\n @param sample_fmt the sample format to inspect\n @return 1 if the sample format is planar, 0 if it is interleaved"]
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the required buffer size for the given audio parameters.\n\n @param[out] linesize calculated linesize, may be NULL\n @param nb_channels   the number of channels\n @param nb_samples    the number of samples in a single channel\n @param sample_fmt    the sample format\n @param align         buffer size alignment (0 = default, 1 = no alignment)\n @return              required buffer size, or negative error code on failure"]
    pub fn av_samples_get_buffer_size(
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill plane data pointers and linesize for samples with sample\n format sample_fmt.\n\n The audio_data array is filled with the pointers to the samples data planes:\n for planar, set the start point of each channel's data within the buffer,\n for packed, set the start point of the entire buffer only.\n\n The value pointed to by linesize is set to the aligned size of each\n channel's data buffer for planar layout, or to the aligned size of the\n buffer for all channels for packed layout.\n\n The buffer in buf must be big enough to contain all the samples\n (use av_samples_get_buffer_size() to compute its minimum size),\n otherwise the audio_data pointers will point to invalid data.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param[out] audio_data  array to be filled with the pointer for each channel\n @param[out] linesize    calculated linesize, may be NULL\n @param buf              the pointer to a buffer containing the samples\n @param nb_channels      the number of channels\n @param nb_samples       the number of samples in a single channel\n @param sample_fmt       the sample format\n @param align            buffer size alignment (0 = default, 1 = no alignment)\n @return                 minimum size in bytes required for the buffer on success,\n                         or a negative error code on failure"]
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        buf: *const u8,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a samples buffer for nb_samples samples, and fill data pointers and\n linesize accordingly.\n The allocated samples buffer can be freed by using av_freep(&audio_data[0])\n Allocated data will be initialized to silence.\n\n @see enum AVSampleFormat\n The documentation for AVSampleFormat describes the data layout.\n\n @param[out] audio_data  array to be filled with the pointer for each channel\n @param[out] linesize    aligned size for audio buffer(s), may be NULL\n @param nb_channels      number of audio channels\n @param nb_samples       number of samples per channel\n @param sample_fmt       the sample format\n @param align            buffer size alignment (0 = default, 1 = no alignment)\n @return                 >=0 on success or a negative error code on failure\n @todo return the size of the allocated buffer in case of success at the next bump\n @see av_samples_fill_arrays()\n @see av_samples_alloc_array_and_samples()"]
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a data pointers array, samples buffer for nb_samples\n samples, and fill data pointers and linesize accordingly.\n\n This is the same as av_samples_alloc(), but also allocates the data\n pointers array.\n\n @see av_samples_alloc()"]
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy samples from src to dst.\n\n @param dst destination array of pointers to data planes\n @param src source array of pointers to data planes\n @param dst_offset offset in samples at which the data will be written to dst\n @param src_offset offset in samples at which the data will be read from src\n @param nb_samples number of samples to be copied\n @param nb_channels number of audio channels\n @param sample_fmt audio sample format"]
    pub fn av_samples_copy(
        dst: *const *mut u8,
        src: *const *mut u8,
        dst_offset: ::std::os::raw::c_int,
        src_offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill an audio buffer with silence.\n\n @param audio_data  array of pointers to data planes\n @param offset      offset in samples at which to start filling\n @param nb_samples  number of samples to fill\n @param nb_channels number of audio channels\n @param sample_fmt  audio sample format"]
    pub fn av_samples_set_silence(
        audio_data: *const *mut u8,
        offset: ::std::os::raw::c_int,
        nb_samples: ::std::os::raw::c_int,
        nb_channels: ::std::os::raw::c_int,
        sample_fmt: AVSampleFormat,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The data is the AVPanScan struct defined in libavcodec."]
pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
#[doc = " ATSC A53 Part 4 Closed Captions.\n A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.\n The number of bytes of CC data is AVFrameSideData.size."]
pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
#[doc = " Stereoscopic 3d metadata.\n The data is the AVStereo3D struct defined in libavutil/stereo3d.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
#[doc = " The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
#[doc = " Metadata relevant to a downmix procedure.\n The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
#[doc = " ReplayGain information in the form of the AVReplayGain struct."]
pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
#[doc = " This side data contains a 3x3 transformation matrix describing an affine\n transformation that needs to be applied to the frame for correct\n presentation.\n\n See libavutil/display.h for a detailed description of the data."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
#[doc = " Active Format Description data consisting of a single byte as specified\n in ETSI TS 101 154 using AVActiveFormatDescription enum."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
#[doc = " Motion vectors exported by some codecs (on demand through the export_mvs\n flag set in the libavcodec AVCodecContext flags2 option).\n The data is the AVMotionVector struct defined in\n libavutil/motion_vector.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
#[doc = " Recommmends skipping the specified number of samples. This is exported\n only if the \"skip_manual\" AVOption is set in libavcodec.\n This has the same format as AV_PKT_DATA_SKIP_SAMPLES.\n @code\n u32le number of samples to skip from start of this packet\n u32le number of samples to skip from end of this packet\n u8    reason for start skip\n u8    reason for end   skip (0=padding silence, 1=convergence)\n @endcode"]
pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
#[doc = " This side data must be associated with an audio frame and corresponds to\n enum AVAudioServiceType defined in avcodec.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
#[doc = " Mastering display metadata associated with a video frame. The payload is\n an AVMasteringDisplayMetadata type and contains information about the\n mastering display color volume."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
#[doc = " The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.\n This is set on the first frame of a GOP that has a temporal reference of 0."]
pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
#[doc = " The data represents the AVSphericalMapping structure defined in\n libavutil/spherical.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
#[doc = " Content light level (based on CTA-861.3). This payload contains data in\n the form of the AVContentLightMetadata struct."]
pub const AVFrameSideDataType_AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
#[doc = " The data contains an ICC profile as an opaque octet buffer following the\n format described by ISO 15076-1 with an optional name defined in the\n metadata key entry \"name\"."]
pub const AVFrameSideDataType_AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
#[doc = " Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t\n where the first uint32_t describes how many (1-3) of the other timecodes are used.\n The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()\n function in libavutil/timecode.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 16;
#[doc = " HDR dynamic metadata associated with a video frame. The payload is\n an AVDynamicHDRPlus type and contains information for color\n volume transform - application 4 of SMPTE 2094-40:2016 standard."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DYNAMIC_HDR_PLUS: AVFrameSideDataType = 17;
#[doc = " Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of\n array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size."]
pub const AVFrameSideDataType_AV_FRAME_DATA_REGIONS_OF_INTEREST: AVFrameSideDataType = 18;
#[doc = " Encoding parameters for a video frame, as described by AVVideoEncParams."]
pub const AVFrameSideDataType_AV_FRAME_DATA_VIDEO_ENC_PARAMS: AVFrameSideDataType = 19;
#[doc = " User data unregistered metadata associated with a video frame.\n This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose\n The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of\n uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte."]
pub const AVFrameSideDataType_AV_FRAME_DATA_SEI_UNREGISTERED: AVFrameSideDataType = 20;
#[doc = " Film grain parameters for a frame, described by AVFilmGrainParams.\n Must be present for every frame which should have film grain applied.\n\n May be present multiple times, for example when there are multiple\n alternative parameter sets for different video signal characteristics.\n The user should select the most appropriate set for the application."]
pub const AVFrameSideDataType_AV_FRAME_DATA_FILM_GRAIN_PARAMS: AVFrameSideDataType = 21;
#[doc = " Bounding boxes for object detection and classification,\n as described by AVDetectionBBoxHeader."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DETECTION_BBOXES: AVFrameSideDataType = 22;
#[doc = " Dolby Vision RPU raw data, suitable for passing to x265\n or other libraries. Array of uint8_t, with NAL emulation\n bytes intact."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DOVI_RPU_BUFFER: AVFrameSideDataType = 23;
#[doc = " Parsed Dolby Vision metadata, suitable for passing to a software\n implementation. The payload is the AVDOVIMetadata struct defined in\n libavutil/dovi_meta.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DOVI_METADATA: AVFrameSideDataType = 24;
#[doc = " HDR Vivid dynamic metadata associated with a video frame. The payload is\n an AVDynamicHDRVivid type and contains information for color\n volume transform - CUVA 005.1-2021."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DYNAMIC_HDR_VIVID: AVFrameSideDataType = 25;
#[doc = " Ambient viewing environment metadata, as defined by H.274."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT: AVFrameSideDataType = 26;
#[doc = " Provide encoder-specific hinting information about changed/unchanged\n portions of a frame.  It can be used to pass information about which\n macroblocks can be skipped because they didn't change from the\n corresponding ones in the previous frame. This could be useful for\n applications which know this information in advance to speed up\n encoding."]
pub const AVFrameSideDataType_AV_FRAME_DATA_VIDEO_HINT: AVFrameSideDataType = 27;
#[doc = " @defgroup lavu_frame AVFrame\n @ingroup lavu_data\n\n @{\n AVFrame is an abstraction for reference-counted raw multimedia data."]
pub type AVFrameSideDataType = ::std::os::raw::c_uint;
pub const AVActiveFormatDescription_AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AVActiveFormatDescription_AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AVActiveFormatDescription_AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AVActiveFormatDescription_AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AVActiveFormatDescription_AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = ::std::os::raw::c_uint;
#[doc = " Structure to hold side data for an AVFrame.\n\n sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added\n to the end with a minor bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: usize,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
impl Default for AVFrameSideData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The side data type can be used in stream-global structures.\n Side data types without this property are only meaningful on per-frame\n basis."]
pub const AVSideDataProps_AV_SIDE_DATA_PROP_GLOBAL: AVSideDataProps = 1;
#[doc = " Multiple instances of this side data type can be meaningfully present in\n a single side data array."]
pub const AVSideDataProps_AV_SIDE_DATA_PROP_MULTI: AVSideDataProps = 2;
pub type AVSideDataProps = ::std::os::raw::c_uint;
#[doc = " This struct describes the properties of a side data type. Its instance\n corresponding to a given type can be obtained from av_frame_side_data_desc()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVSideDataDescriptor {
    #[doc = " Human-readable side data description."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Side data property flags, a combination of AVSideDataProps values."]
    pub props: ::std::os::raw::c_uint,
}
impl Default for AVSideDataDescriptor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure describing a single Region Of Interest.\n\n When multiple regions are defined in a single side-data block, they\n should be ordered from most to least important - some encoders are only\n capable of supporting a limited number of distinct regions, so will have\n to truncate the list.\n\n When overlapping regions are defined, the first region containing a given\n area of the frame applies."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVRegionOfInterest {
    #[doc = " Must be set to the size of this data structure (that is,\n sizeof(AVRegionOfInterest))."]
    pub self_size: u32,
    #[doc = " Distance in pixels from the top edge of the frame to the top and\n bottom edges and from the left edge of the frame to the left and\n right edges of the rectangle defining this region of interest.\n\n The constraints on a region are encoder dependent, so the region\n actually affected may be slightly larger for alignment or other\n reasons."]
    pub top: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    #[doc = " Quantisation offset.\n\n Must be in the range -1 to +1.  A value of zero indicates no quality\n change.  A negative value asks for better quality (less quantisation),\n while a positive value asks for worse quality (greater quantisation).\n\n The range is calibrated so that the extreme values indicate the\n largest possible offset - if the rest of the frame is encoded with the\n worst possible quality, an offset of -1 indicates that this region\n should be encoded with the best possible quality anyway.  Intermediate\n values are then interpolated in some codec-dependent way.\n\n For example, in 10-bit H.264 the quantisation parameter varies between\n -12 and 51.  A typical qoffset value of -1/10 therefore indicates that\n this region should be encoded with a QP around one-tenth of the full\n range better than the rest of the frame.  So, if most of the frame\n were to be encoded with a QP of around 30, this region would get a QP\n of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).\n An extreme value of -1 would indicate that this region should be\n encoded with the best possible quality regardless of the treatment of\n the rest of the frame - that is, should be encoded at a QP of -12."]
    pub qoffset: AVRational,
}
#[doc = " This structure describes decoded (raw) audio or video data.\n\n AVFrame must be allocated using av_frame_alloc(). Note that this only\n allocates the AVFrame itself, the buffers for the data must be managed\n through other means (see below).\n AVFrame must be freed with av_frame_free().\n\n AVFrame is typically allocated once and then reused multiple times to hold\n different data (e.g. a single AVFrame to hold frames received from a\n decoder). In such a case, av_frame_unref() will free any references held by\n the frame and reset it to its original clean state before it\n is reused again.\n\n The data described by an AVFrame is usually reference counted through the\n AVBuffer API. The underlying buffer references are stored in AVFrame.buf /\n AVFrame.extended_buf. An AVFrame is considered to be reference counted if at\n least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,\n every single data plane must be contained in one of the buffers in\n AVFrame.buf or AVFrame.extended_buf.\n There may be a single buffer for all the data, or one separate buffer for\n each plane, or anything in between.\n\n sizeof(AVFrame) is not a part of the public ABI, so new fields may be added\n to the end with a minor bump.\n\n Fields can be accessed through AVOptions, the name string used, matches the\n C structure field name for fields accessible through AVOptions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFrame {
    #[doc = " pointer to the picture/channel planes.\n This might be different from the first allocated byte. For video,\n it could even point to the end of the image data.\n\n All pointers in data and extended_data must point into one of the\n AVBufferRef in buf or extended_buf.\n\n Some decoders access areas outside 0,0 - width,height, please\n see avcodec_align_dimensions2(). Some filters and swscale can read\n up to 16 bytes beyond the planes, if these filters are to be used,\n then 16 extra bytes must be allocated.\n\n NOTE: Pointers not needed by the format MUST be set to NULL.\n\n @attention In case of video, the data[] pointers can point to the\n end of image data in order to reverse line order, when used in\n combination with negative values in the linesize[] array."]
    pub data: [*mut u8; 8usize],
    #[doc = " For video, a positive or negative value, which is typically indicating\n the size in bytes of each picture line, but it can also be:\n - the negative byte size of lines for vertical flipping\n   (with data[n] pointing to the end of the data\n - a positive or negative multiple of the byte size as for accessing\n   even and odd fields of a frame (possibly flipped)\n\n For audio, only linesize[0] may be set. For planar audio, each channel\n plane must be the same size.\n\n For video the linesizes should be multiples of the CPUs alignment\n preference, this is 16 or 32 for modern desktop CPUs.\n Some code requires such alignment other code can be slower without\n correct alignment, for yet other it makes no difference.\n\n @note The linesize may be larger than the size of usable data -- there\n may be extra padding present for performance reasons.\n\n @attention In case of video, line size values can be negative to achieve\n a vertically inverted iteration over image lines."]
    pub linesize: [::std::os::raw::c_int; 8usize],
    #[doc = " pointers to the data planes/channels.\n\n For video, this should simply point to data[].\n\n For planar audio, each channel has a separate data pointer, and\n linesize[0] contains the size of each channel buffer.\n For packed audio, there is just one data pointer, and linesize[0]\n contains the total size of the buffer for all channels.\n\n Note: Both data and extended_data should always be set in a valid frame,\n but for planar audio with more channels that can fit in data,\n extended_data must be used in order to access all channels."]
    pub extended_data: *mut *mut u8,
    #[doc = " @name Video dimensions\n Video frames only. The coded dimensions (in pixels) of the video frame,\n i.e. the size of the rectangle that contains some well-defined values.\n\n @note The part of the frame intended for display/presentation is further\n restricted by the @ref cropping \"Cropping rectangle\".\n @{"]
    pub width: ::std::os::raw::c_int,
    #[doc = " @name Video dimensions\n Video frames only. The coded dimensions (in pixels) of the video frame,\n i.e. the size of the rectangle that contains some well-defined values.\n\n @note The part of the frame intended for display/presentation is further\n restricted by the @ref cropping \"Cropping rectangle\".\n @{"]
    pub height: ::std::os::raw::c_int,
    #[doc = " number of audio samples (per channel) described by this frame"]
    pub nb_samples: ::std::os::raw::c_int,
    #[doc = " format of the frame, -1 if unknown or unset\n Values correspond to enum AVPixelFormat for video frames,\n enum AVSampleFormat for audio)"]
    pub format: ::std::os::raw::c_int,
    #[doc = " 1 -> keyframe, 0-> not\n\n @deprecated Use AV_FRAME_FLAG_KEY instead"]
    pub key_frame: ::std::os::raw::c_int,
    #[doc = " Picture type of the frame."]
    pub pict_type: AVPictureType,
    #[doc = " Sample aspect ratio for the video frame, 0/1 if unknown/unspecified."]
    pub sample_aspect_ratio: AVRational,
    #[doc = " Presentation timestamp in time_base units (time when frame should be shown to user)."]
    pub pts: i64,
    #[doc = " DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)\n This is also the Presentation time of this AVFrame calculated from\n only AVPacket.dts values without pts values."]
    pub pkt_dts: i64,
    #[doc = " Time base for the timestamps in this frame.\n In the future, this field may be set on frames output by decoders or\n filters, but its value will be by default ignored on input to encoders\n or filters."]
    pub time_base: AVRational,
    #[doc = " quality (between 1 (good) and FF_LAMBDA_MAX (bad))"]
    pub quality: ::std::os::raw::c_int,
    #[doc = " Frame owner's private data.\n\n This field may be set by the code that allocates/owns the frame data.\n It is then not touched by any library functions, except:\n - it is copied to other references by av_frame_copy_props() (and hence by\n   av_frame_ref());\n - it is set to NULL when the frame is cleared by av_frame_unref()\n - on the caller's explicit request. E.g. libavcodec encoders/decoders\n   will copy this field to/from @ref AVPacket \"AVPackets\" if the caller sets\n   @ref AV_CODEC_FLAG_COPY_OPAQUE.\n\n @see opaque_ref the reference-counted analogue"]
    pub opaque: *mut ::std::os::raw::c_void,
    #[doc = " Number of fields in this frame which should be repeated, i.e. the total\n duration of this frame should be repeat_pict + 2 normal field durations.\n\n For interlaced frames this field may be set to 1, which signals that this\n frame should be presented as 3 fields: beginning with the first field (as\n determined by AV_FRAME_FLAG_TOP_FIELD_FIRST being set or not), followed\n by the second field, and then the first field again.\n\n For progressive frames this field may be set to a multiple of 2, which\n signals that this frame's duration should be (repeat_pict + 2) / 2\n normal frame durations.\n\n @note This field is computed from MPEG2 repeat_first_field flag and its\n associated flags, H.264 pic_struct from picture timing SEI, and\n their analogues in other codecs. Typically it should only be used when\n higher-layer timing information is not available."]
    pub repeat_pict: ::std::os::raw::c_int,
    #[doc = " The content of the picture is interlaced.\n\n @deprecated Use AV_FRAME_FLAG_INTERLACED instead"]
    pub interlaced_frame: ::std::os::raw::c_int,
    #[doc = " If the content is interlaced, is top field displayed first.\n\n @deprecated Use AV_FRAME_FLAG_TOP_FIELD_FIRST instead"]
    pub top_field_first: ::std::os::raw::c_int,
    #[doc = " Tell user application that palette has changed from previous frame."]
    pub palette_has_changed: ::std::os::raw::c_int,
    #[doc = " Sample rate of the audio data."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " AVBuffer references backing the data for this frame. All the pointers in\n data and extended_data must point inside one of the buffers in buf or\n extended_buf. This array must be filled contiguously -- if buf[i] is\n non-NULL then buf[j] must also be non-NULL for all j < i.\n\n There may be at most one AVBuffer per data plane, so for video this array\n always contains all the references. For planar audio with more than\n AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in\n this array. Then the extra AVBufferRef pointers are stored in the\n extended_buf array."]
    pub buf: [*mut AVBufferRef; 8usize],
    #[doc = " For planar audio which requires more than AV_NUM_DATA_POINTERS\n AVBufferRef pointers, this array will hold all the references which\n cannot fit into AVFrame.buf.\n\n Note that this is different from AVFrame.extended_data, which always\n contains all the pointers. This array only contains the extra pointers,\n which cannot fit into AVFrame.buf.\n\n This array is always allocated using av_malloc() by whoever constructs\n the frame. It is freed in av_frame_unref()."]
    pub extended_buf: *mut *mut AVBufferRef,
    #[doc = " Number of elements in extended_buf."]
    pub nb_extended_buf: ::std::os::raw::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: ::std::os::raw::c_int,
    #[doc = " Frame flags, a combination of @ref lavu_frame_flags"]
    pub flags: ::std::os::raw::c_int,
    #[doc = " MPEG vs JPEG YUV range.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    #[doc = " YUV colorspace type.\n - encoding: Set by user\n - decoding: Set by libavcodec"]
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    #[doc = " frame timestamp estimated using various heuristics, in stream time base\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub best_effort_timestamp: i64,
    #[doc = " reordered pos from the last AVPacket that has been input into the decoder\n - encoding: unused\n - decoding: Read by user.\n @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user\n             data from packets to frames"]
    pub pkt_pos: i64,
    #[doc = " metadata.\n - encoding: Set by user.\n - decoding: Set by libavcodec."]
    pub metadata: *mut AVDictionary,
    #[doc = " decode error flags of the frame, set to a combination of\n FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there\n were errors during the decoding.\n - encoding: unused\n - decoding: set by libavcodec, read by user."]
    pub decode_error_flags: ::std::os::raw::c_int,
    #[doc = " size of the corresponding packet containing the compressed\n frame.\n It is set to a negative value if unknown.\n - encoding: unused\n - decoding: set by libavcodec, read by user.\n @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user\n             data from packets to frames"]
    pub pkt_size: ::std::os::raw::c_int,
    #[doc = " For hwaccel-format frames, this should be a reference to the\n AVHWFramesContext describing the frame."]
    pub hw_frames_ctx: *mut AVBufferRef,
    #[doc = " Frame owner's private data.\n\n This field may be set by the code that allocates/owns the frame data.\n It is then not touched by any library functions, except:\n - a new reference to the underlying buffer is propagated by\n   av_frame_copy_props() (and hence by av_frame_ref());\n - it is unreferenced in av_frame_unref();\n - on the caller's explicit request. E.g. libavcodec encoders/decoders\n   will propagate a new reference to/from @ref AVPacket \"AVPackets\" if the\n   caller sets @ref AV_CODEC_FLAG_COPY_OPAQUE.\n\n @see opaque the plain pointer analogue"]
    pub opaque_ref: *mut AVBufferRef,
    #[doc = " @anchor cropping\n @name Cropping\n Video frames only. The number of pixels to discard from the the\n top/bottom/left/right border of the frame to obtain the sub-rectangle of\n the frame intended for presentation.\n @{"]
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
    #[doc = " AVBufferRef for internal use by a single libav* library.\n Must not be used to transfer data between libraries.\n Has to be NULL when ownership of the frame leaves the respective library.\n\n Code outside the FFmpeg libs should never check or change the contents of the buffer ref.\n\n FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.\n av_frame_copy_props() calls create a new reference with av_buffer_ref()\n for the target frame's private_ref field."]
    pub private_ref: *mut AVBufferRef,
    #[doc = " Channel layout of the audio data."]
    pub ch_layout: AVChannelLayout,
    #[doc = " Duration of the frame, in the same units as pts. 0 if unknown."]
    pub duration: i64,
}
impl Default for AVFrame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Allocate an AVFrame and set its fields to default values.  The resulting\n struct must be freed using av_frame_free().\n\n @return An AVFrame filled with default values or NULL on failure.\n\n @note this only allocates the AVFrame itself, not the data buffers. Those\n must be allocated through other means, e.g. with av_frame_get_buffer() or\n manually."]
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    #[doc = " Free the frame and any dynamically allocated objects in it,\n e.g. extended_data. If the frame is reference counted, it will be\n unreferenced first.\n\n @param frame frame to be freed. The pointer will be set to NULL."]
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    #[doc = " Set up a new reference to the data described by the source frame.\n\n Copy frame properties from src to dst and create a new reference for each\n AVBufferRef from src.\n\n If src is not reference counted, new buffers are allocated and the data is\n copied.\n\n @warning: dst MUST have been either unreferenced with av_frame_unref(dst),\n           or newly allocated with av_frame_alloc() before calling this\n           function, or undefined behavior will occur.\n\n @return 0 on success, a negative AVERROR on error"]
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure the destination frame refers to the same data described by the source\n frame, either by creating a new reference for each AVBufferRef from src if\n they differ from those in dst, by allocating new buffers and copying data if\n src is not reference counted, or by unrefencing it if src is empty.\n\n Frame properties on dst will be replaced by those from src.\n\n @return 0 on success, a negative AVERROR on error. On error, dst is\n         unreferenced."]
    pub fn av_frame_replace(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new frame that references the same data as src.\n\n This is a shortcut for av_frame_alloc()+av_frame_ref().\n\n @return newly created AVFrame on success, NULL on error."]
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    #[doc = " Unreference all the buffers referenced by frame and reset the frame fields."]
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    #[doc = " Move everything contained in src to dst and reset src.\n\n @warning: dst is not unreferenced, but directly overwritten without reading\n           or deallocating its contents. Call av_frame_unref(dst) manually\n           before calling this function to ensure that no memory is leaked."]
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    #[doc = " Allocate new buffer(s) for audio or video data.\n\n The following fields must be set on frame before calling this function:\n - format (pixel format for video, sample format for audio)\n - width and height for video\n - nb_samples and ch_layout for audio\n\n This function will fill AVFrame.data and AVFrame.buf arrays and, if\n necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.\n For planar formats, one buffer will be allocated for each plane.\n\n @warning: if frame already has been allocated, calling this function will\n           leak memory. In addition, undefined behavior can occur in certain\n           cases.\n\n @param frame frame in which to store the new buffers.\n @param align Required buffer size alignment. If equal to 0, alignment will be\n              chosen automatically for the current CPU. It is highly\n              recommended to pass 0 here unless you know what you are doing.\n\n @return 0 on success, a negative AVERROR on error."]
    pub fn av_frame_get_buffer(
        frame: *mut AVFrame,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the frame data is writable.\n\n @return A positive value if the frame data is writable (which is true if and\n only if each of the underlying buffers has only one reference, namely the one\n stored in this frame). Return 0 otherwise.\n\n If 1 is returned the answer is valid until av_buffer_ref() is called on any\n of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).\n\n @see av_frame_make_writable(), av_buffer_is_writable()"]
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensure that the frame data is writable, avoiding data copy if possible.\n\n Do nothing if the frame is writable, allocate new buffers and copy the data\n if it is not. Non-refcounted frames behave as non-writable, i.e. a copy\n is always made.\n\n @return 0 on success, a negative AVERROR on error.\n\n @see av_frame_is_writable(), av_buffer_is_writable(),\n av_buffer_make_writable()"]
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the frame data from src to dst.\n\n This function does not allocate anything, dst must be already initialized and\n allocated with the same parameters as src.\n\n This function only copies the frame data (i.e. the contents of the data /\n extended data arrays), not any other properties.\n\n @return >= 0 on success, a negative AVERROR on error."]
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy only \"metadata\" fields from src to dst.\n\n Metadata for the purpose of this function are those fields that do not affect\n the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample\n aspect ratio (for video), but not width/height or channel layout.\n Side data is also copied."]
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the buffer reference a given data plane is stored in.\n\n @param frame the frame to get the plane's buffer from\n @param plane index of the data plane of interest in frame->extended_data.\n\n @return the buffer reference that contains the plane or NULL if the input\n frame is not valid."]
    pub fn av_frame_get_plane_buffer(
        frame: *const AVFrame,
        plane: ::std::os::raw::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    #[doc = " Add a new side data to a frame.\n\n @param frame a frame to which the side data should be added\n @param type type of the added side data\n @param size size of the side data\n\n @return newly added side data on success, NULL on error"]
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: usize,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Add a new side data to a frame from an existing AVBufferRef\n\n @param frame a frame to which the side data should be added\n @param type  the type of the added side data\n @param buf   an AVBufferRef to add as side data. The ownership of\n              the reference is transferred to the frame.\n\n @return newly added side data on success, NULL on error. On failure\n         the frame is unchanged and the AVBufferRef remains owned by\n         the caller."]
    pub fn av_frame_new_side_data_from_buf(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        buf: *mut AVBufferRef,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " @return a pointer to the side data of a given type on success, NULL if there\n is no side data with such type in this frame."]
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Remove and free all side data instances of the given type."]
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
#[doc = " Apply the maximum possible cropping, even if it requires setting the\n AVFrame.data[] entries to unaligned pointers. Passing unaligned data\n to FFmpeg API is generally not allowed, and causes undefined behavior\n (such as crashes). You can pass unaligned data only to FFmpeg APIs that\n are explicitly documented to accept it. Use this flag only if you\n absolutely know what you are doing."]
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_1 = 1;
#[doc = " Flags for frame cropping."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Crop the given video AVFrame according to its crop_left/crop_top/crop_right/\n crop_bottom fields. If cropping is successful, the function will adjust the\n data pointers and the width/height fields, and set the crop fields to 0.\n\n In all cases, the cropping boundaries will be rounded to the inherent\n alignment of the pixel format. In some cases, such as for opaque hwaccel\n formats, the left/top cropping is ignored. The crop fields are set to 0 even\n if the cropping was rounded or ignored.\n\n @param frame the frame which should be cropped\n @param flags Some combination of AV_FRAME_CROP_* flags, or 0.\n\n @return >= 0 on success, a negative AVERROR on error. If the cropping fields\n were invalid, AVERROR(ERANGE) is returned, and nothing is changed."]
    pub fn av_frame_apply_cropping(
        frame: *mut AVFrame,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a string identifying the side data type"]
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return side data descriptor corresponding to a given side data type, NULL\n         when not available."]
    pub fn av_frame_side_data_desc(type_: AVFrameSideDataType) -> *const AVSideDataDescriptor;
}
extern "C" {
    #[doc = " Free all side data entries and their contents, then zeroes out the\n values which the pointers are pointing to.\n\n @param sd    pointer to array of side data to free. Will be set to NULL\n              upon return.\n @param nb_sd pointer to an integer containing the number of entries in\n              the array. Will be set to 0 upon return."]
    pub fn av_frame_side_data_free(
        sd: *mut *mut *mut AVFrameSideData,
        nb_sd: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Add new side data entry to an array.\n\n @param sd    pointer to array of side data to which to add another entry,\n              or to NULL in order to start a new array.\n @param nb_sd pointer to an integer containing the number of entries in\n              the array.\n @param type  type of the added side data\n @param size  size of the side data\n @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.\n\n @return newly added side data on success, NULL on error.\n @note In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of\n       matching AVFrameSideDataType will be removed before the addition\n       is attempted.\n @note In case of AV_FRAME_SIDE_DATA_FLAG_REPLACE being set, if an\n       entry of the same type already exists, it will be replaced instead."]
    pub fn av_frame_side_data_new(
        sd: *mut *mut *mut AVFrameSideData,
        nb_sd: *mut ::std::os::raw::c_int,
        type_: AVFrameSideDataType,
        size: usize,
        flags: ::std::os::raw::c_uint,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Add a new side data entry to an array from an existing AVBufferRef.\n\n @param sd    pointer to array of side data to which to add another entry,\n              or to NULL in order to start a new array.\n @param nb_sd pointer to an integer containing the number of entries in\n              the array.\n @param type  type of the added side data\n @param buf   Pointer to AVBufferRef to add to the array. On success,\n              the function takes ownership of the AVBufferRef and *buf is\n              set to NULL, unless AV_FRAME_SIDE_DATA_FLAG_NEW_REF is set\n              in which case the ownership will remain with the caller.\n @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.\n\n @return newly added side data on success, NULL on error.\n @note In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of\n       matching AVFrameSideDataType will be removed before the addition\n       is attempted.\n @note In case of AV_FRAME_SIDE_DATA_FLAG_REPLACE being set, if an\n       entry of the same type already exists, it will be replaced instead.\n"]
    pub fn av_frame_side_data_add(
        sd: *mut *mut *mut AVFrameSideData,
        nb_sd: *mut ::std::os::raw::c_int,
        type_: AVFrameSideDataType,
        buf: *mut *mut AVBufferRef,
        flags: ::std::os::raw::c_uint,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    #[doc = " Add a new side data entry to an array based on existing side data, taking\n a reference towards the contained AVBufferRef.\n\n @param sd    pointer to array of side data to which to add another entry,\n              or to NULL in order to start a new array.\n @param nb_sd pointer to an integer containing the number of entries in\n              the array.\n @param src   side data to be cloned, with a new reference utilized\n              for the buffer.\n @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.\n\n @return negative error code on failure, >=0 on success.\n @note In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of\n       matching AVFrameSideDataType will be removed before the addition\n       is attempted.\n @note In case of AV_FRAME_SIDE_DATA_FLAG_REPLACE being set, if an\n       entry of the same type already exists, it will be replaced instead."]
    pub fn av_frame_side_data_clone(
        sd: *mut *mut *mut AVFrameSideData,
        nb_sd: *mut ::std::os::raw::c_int,
        src: *const AVFrameSideData,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a side data entry of a specific type from an array.\n\n @param sd    array of side data.\n @param nb_sd integer containing the number of entries in the array.\n @param type  type of side data to be queried\n\n @return a pointer to the side data of a given type on success, NULL if there\n         is no side data with such type in this set."]
    pub fn av_frame_side_data_get_c(
        sd: *const *const AVFrameSideData,
        nb_sd: ::std::os::raw::c_int,
        type_: AVFrameSideDataType,
    ) -> *const AVFrameSideData;
}
extern "C" {
    #[doc = " Remove and free all side data instances of the given type from an array."]
    pub fn av_frame_side_data_remove(
        sd: *mut *mut *mut AVFrameSideData,
        nb_sd: *mut ::std::os::raw::c_int,
        type_: AVFrameSideDataType,
    );
}
extern "C" {
    #[doc = " @defgroup libsws libswscale\n Color conversion and scaling library.\n\n @{\n\n Return the LIBSWSCALE_VERSION_INT constant."]
    pub fn swscale_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the libswscale build-time configuration."]
    pub fn swscale_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the libswscale license."]
    pub fn swscale_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a pointer to yuv<->rgb coefficients for the given colorspace\n suitable for sws_setColorspaceDetails().\n\n @param colorspace One of the SWS_CS_* macros. If invalid,\n SWS_CS_DEFAULT is used."]
    pub fn sws_getCoefficients(colorspace: ::std::os::raw::c_int) -> *const ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SwsVector {
    #[doc = "< pointer to the list of coefficients"]
    pub coeff: *mut f64,
    #[doc = "< number of coefficients in the vector"]
    pub length: ::std::os::raw::c_int,
}
impl Default for SwsVector {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
impl Default for SwsFilter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported input format, 0\n otherwise."]
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a positive value if pix_fmt is a supported output format, 0\n otherwise."]
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param[in]  pix_fmt the pixel format\n @return a positive value if an endianness conversion for pix_fmt is\n supported, 0 otherwise."]
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate an empty SwsContext. This must be filled and passed to\n sws_init_context(). For filling see AVOptions, options.c and\n sws_setColorspaceDetails()."]
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    #[must_use]
    #[doc = " Initialize the swscaler context sws_context.\n\n @return zero or positive value on success, a negative value on\n error"]
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the swscaler context swsContext.\n If swsContext is NULL, then does nothing."]
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    #[doc = " Allocate and return an SwsContext. You need it to perform\n scaling/conversion operations using sws_scale().\n\n @param srcW the width of the source image\n @param srcH the height of the source image\n @param srcFormat the source image format\n @param dstW the width of the destination image\n @param dstH the height of the destination image\n @param dstFormat the destination image format\n @param flags specify which algorithm and options to use for rescaling\n @param param extra parameters to tune the used scaler\n              For SWS_BICUBIC param[0] and [1] tune the shape of the basis\n              function, param[0] tunes f(1) and param[1] f(1)\n              For SWS_GAUSS param[0] tunes the exponent and thus cutoff\n              frequency\n              For SWS_LANCZOS param[0] tunes the width of the window function\n @return a pointer to an allocated context, or NULL in case of error\n @note this function is to be removed after a saner alternative is\n       written"]
    pub fn sws_getContext(
        srcW: ::std::os::raw::c_int,
        srcH: ::std::os::raw::c_int,
        srcFormat: AVPixelFormat,
        dstW: ::std::os::raw::c_int,
        dstH: ::std::os::raw::c_int,
        dstFormat: AVPixelFormat,
        flags: ::std::os::raw::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Scale the image slice in srcSlice and put the resulting scaled\n slice in the image in dst. A slice is a sequence of consecutive\n rows in an image.\n\n Slices have to be provided in sequential order, either in\n top-bottom or bottom-top order. If slices are provided in\n non-sequential order the behavior of the function is undefined.\n\n @param c         the scaling context previously created with\n                  sws_getContext()\n @param srcSlice  the array containing the pointers to the planes of\n                  the source slice\n @param srcStride the array containing the strides for each plane of\n                  the source image\n @param srcSliceY the position in the source image of the slice to\n                  process, that is the number (counted starting from\n                  zero) in the image of the first row of the slice\n @param srcSliceH the height of the source slice, that is the number\n                  of rows in the slice\n @param dst       the array containing the pointers to the planes of\n                  the destination image\n @param dstStride the array containing the strides for each plane of\n                  the destination image\n @return          the height of the output slice"]
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const ::std::os::raw::c_int,
        srcSliceY: ::std::os::raw::c_int,
        srcSliceH: ::std::os::raw::c_int,
        dst: *const *mut u8,
        dstStride: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Scale source data from src and write the output to dst.\n\n This is merely a convenience wrapper around\n - sws_frame_start()\n - sws_send_slice(0, src->height)\n - sws_receive_slice(0, dst->height)\n - sws_frame_end()\n\n @param c   The scaling context\n @param dst The destination frame. See documentation for sws_frame_start() for\n            more details.\n @param src The source frame.\n\n @return 0 on success, a negative AVERROR code on failure"]
    pub fn sws_scale_frame(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the scaling process for a given pair of source/destination frames.\n Must be called before any calls to sws_send_slice() and sws_receive_slice().\n\n This function will retain references to src and dst, so they must both use\n refcounted buffers (if allocated by the caller, in case of dst).\n\n @param c   The scaling context\n @param dst The destination frame.\n\n            The data buffers may either be already allocated by the caller or\n            left clear, in which case they will be allocated by the scaler.\n            The latter may have performance advantages - e.g. in certain cases\n            some output planes may be references to input planes, rather than\n            copies.\n\n            Output data will be written into this frame in successful\n            sws_receive_slice() calls.\n @param src The source frame. The data buffers must be allocated, but the\n            frame data does not have to be ready at this point. Data\n            availability is then signalled by sws_send_slice().\n @return 0 on success, a negative AVERROR code on failure\n\n @see sws_frame_end()"]
    pub fn sws_frame_start(
        c: *mut SwsContext,
        dst: *mut AVFrame,
        src: *const AVFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finish the scaling process for a pair of source/destination frames previously\n submitted with sws_frame_start(). Must be called after all sws_send_slice()\n and sws_receive_slice() calls are done, before any new sws_frame_start()\n calls.\n\n @param c   The scaling context"]
    pub fn sws_frame_end(c: *mut SwsContext);
}
extern "C" {
    #[doc = " Indicate that a horizontal slice of input data is available in the source\n frame previously provided to sws_frame_start(). The slices may be provided in\n any order, but may not overlap. For vertically subsampled pixel formats, the\n slices must be aligned according to subsampling.\n\n @param c   The scaling context\n @param slice_start first row of the slice\n @param slice_height number of rows in the slice\n\n @return a non-negative number on success, a negative AVERROR code on failure."]
    pub fn sws_send_slice(
        c: *mut SwsContext,
        slice_start: ::std::os::raw::c_uint,
        slice_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request a horizontal slice of the output data to be written into the frame\n previously provided to sws_frame_start().\n\n @param c   The scaling context\n @param slice_start first row of the slice; must be a multiple of\n                    sws_receive_slice_alignment()\n @param slice_height number of rows in the slice; must be a multiple of\n                     sws_receive_slice_alignment(), except for the last slice\n                     (i.e. when slice_start+slice_height is equal to output\n                     frame height)\n\n @return a non-negative number if the data was successfully written into the output\n         AVERROR(EAGAIN) if more input data needs to be provided before the\n                         output can be produced\n         another negative AVERROR code on other kinds of scaling failure"]
    pub fn sws_receive_slice(
        c: *mut SwsContext,
        slice_start: ::std::os::raw::c_uint,
        slice_height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the alignment required for slices\n\n @param c   The scaling context\n @return alignment required for output slices requested with sws_receive_slice().\n         Slice offsets and sizes passed to sws_receive_slice() must be\n         multiples of the value returned from this function."]
    pub fn sws_receive_slice_alignment(c: *const SwsContext) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @param c the scaling context\n @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)\n @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)\n @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]\n @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]\n @param brightness 16.16 fixed point brightness correction\n @param contrast 16.16 fixed point contrast correction\n @param saturation 16.16 fixed point saturation correction\n\n @return A negative error code on error, non negative otherwise.\n         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported."]
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const ::std::os::raw::c_int,
        srcRange: ::std::os::raw::c_int,
        table: *const ::std::os::raw::c_int,
        dstRange: ::std::os::raw::c_int,
        brightness: ::std::os::raw::c_int,
        contrast: ::std::os::raw::c_int,
        saturation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return A negative error code on error, non negative otherwise.\n         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported."]
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut ::std::os::raw::c_int,
        srcRange: *mut ::std::os::raw::c_int,
        table: *mut *mut ::std::os::raw::c_int,
        dstRange: *mut ::std::os::raw::c_int,
        brightness: *mut ::std::os::raw::c_int,
        contrast: *mut ::std::os::raw::c_int,
        saturation: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and return an uninitialized vector with length coefficients."]
    pub fn sws_allocVec(length: ::std::os::raw::c_int) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Return a normalized Gaussian curve used to filter stuff\n quality = 3 is high quality, lower is lower quality."]
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    #[doc = " Scale all the coefficients of a by the scalar value."]
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    #[doc = " Scale all the coefficients of a so that their sum equals height."]
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: ::std::os::raw::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    #[doc = " Check if context can be reused, otherwise reallocate a new one.\n\n If context is NULL, just calls sws_getContext() to get a new\n context. Otherwise, checks if the parameters are the ones already\n saved in context. If that is the case, returns the current\n context. Otherwise, frees context and gets a new context with\n the new parameters.\n\n Be warned that srcFilter and dstFilter are not checked, they\n are assumed to remain the same."]
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: ::std::os::raw::c_int,
        srcH: ::std::os::raw::c_int,
        srcFormat: AVPixelFormat,
        dstW: ::std::os::raw::c_int,
        dstH: ::std::os::raw::c_int,
        dstFormat: AVPixelFormat,
        flags: ::std::os::raw::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.\n\n The output frame will have the same packed format as the palette.\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: ::std::os::raw::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.\n\n With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".\n\n @param src        source frame buffer\n @param dst        destination frame buffer\n @param num_pixels number of pixels to convert\n @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src"]
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: ::std::os::raw::c_int,
        palette: *const u8,
    );
}
extern "C" {
    #[doc = " Get the AVClass for swsContext. It can be used in combination with\n AV_OPT_SEARCH_FAKE_OBJ for examining options.\n\n @see av_opt_find()."]
    pub fn sws_get_class() -> *const AVClass;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
#[doc = " a pointer to the first option specified in the class if any or NULL\n\n @see av_set_default_options()"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVOption {
    pub _address: u8,
}
